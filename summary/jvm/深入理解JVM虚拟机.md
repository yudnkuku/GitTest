# 深入理解JVM虚拟机

标签（空格分隔）： 读书笔记

---

## Chapter 1 Java内存区域与内存溢出异常 ##
## 运行时数据区域 ##
**1、程序计数器**

程序计数器(`Program Counter Register`)是一块较小的内存区域，可以看作是当前线程所执行的字节码的行号指示器，为了线程切换后能恢复到正确的执行位置，每条线程都必须要有一个**独立**的程序计数器，因此程序计数器是**线程私有**的，此内存区域是`JAVA`虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域。

**2、JAVA虚拟机栈**

`JAVA`虚拟机栈存储了**局部变量表，操作数栈，动态链表，方法出口**等信息，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程，因此此区域也是**线程私有的**

**3、本地方法栈**

顾名思义，`JAVA`虚拟机栈是为虚拟机执行`JAVA`方法也就是字节码服务的，而本地方法栈是为`Native`方法服务的。

**4、JAVA堆**

`JAVA`堆是虚拟机管理的内存中最大的一块，是被所有线程共享的一块内存区域，此内存的唯一目的就是存放对象实例，`JAVA`堆也是`GC`收集器回收内存的主要区域，因此也称为`GC`堆，由于现在的收集器基本采用分代收集算法，所以`JAVA`堆还可以细分为：新生代和老年代，再细分点可以分为：`Eden`空间、`From Survivor`空间、`To Survivor`空间等。

**5、方法区**

方法区和`JAVA`堆一样也是线程共享的区域，它用于存放虚拟机加载的**类信息、常量、静态成员变量、即时编译期编译(JIT)后的代码**等数据(方法区用于存放`Class`的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等)，很多人习惯把方法区叫做永久代(`Permanent Generation`)，但两者实际上并不等价，永久代只是`Hotspot`虚拟机中方法区的别称。**方法区也叫作静态域。**

**运行时常量池**

运行时常量池是方法区的一部分，`Class`文件中除了有类的版本、字段、方法、接口等描述信息之外，还有一项是常量池(`Constant Pool Table`)，用于存放编译期生成的各种**字面量和符号引用**，这部分内容将在类加载后进入方法区的运行时常量池中存放。
`JAVA`虚拟机对`Class`文件中的每一部分的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，`Java`虚拟机规范没有任何规定，一般来说，除了保存`Class`文件中描述的符号引用外，还会把翻译出来的**直接引用**也存储在运行时常量池。
运行常量池相对于`Class`常量池的另外一个重要特征是具备动态性，`Java`语言不要求常量一定只有编译期才能产生，也就是并非预置入`Class`文件中常量池的内容才能进入方法区运行时常量池，**运行期间也可能将新的常量放入池中**，这种特性被开发人员利用得比较多的便是`String`类的`intern()`方法。

**小结**：程序计数器、`JAVA`虚拟机栈和本地方法栈是线程私有的，而`JAVA`堆和方法区是线程共享的。

## 对象分配 ##
随着`JIT`编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，
所有的对象分配到堆上也不那么绝对了。

**逃逸分析**

在编译期间，`JIT`会对代码做很多的优化，其中有一部分的目的是**减少内存堆分配**的压力，其中一项重要的技术叫做逃逸分析。

1、方法逃逸

逃逸分析基本行为就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法调用，例如作为调用参数传递到其他方法中，称为方法逃逸

2、线程逃逸

甚至还有可能被其他线程访问到，譬如复制给类变量或者在其他线程中访问的实例变量，称为线程逃逸

通过逃逸分析，`HotSpot`编译器能够分析出一个新的对象的引用的使用范围，从而决定是否将这个对象分配到堆上，在`jdk 1.6_23`版本之后,`HotSpot`就默认开启了逃逸分析。

开启：`-XX:+DoEscapeAnalysis`(只能在`server`模式下开启)

关闭：`-XX:-DoEscapeAnalysis`

查看分析结果：`-XX:+PrintEscapeAnalysis`

**优化手段**

如果能证明对象无法逃逸到方法或者线程之外，也就是别的方法或者线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效优化。

**栈上分配(`Stack Allocation`)**

一般虚拟机会将对象分配在堆内存中并对其进行管理，但是**如果确定某个对象不会逃逸到方法之外**，那么可以**直接将该对象分配到栈内存**上，对象所占用的空间随着栈帧出栈销毁，
在一般应用中，不会逃逸的局部变量占比很大，如果使用栈内存分配这些对象，那么会减少垃圾回收系统的压力。

**`TLAB`(`Thread Local Allocation Buffer`)上分配**

占用`Eden`空间(可见`TLAB`属于堆)，在`TLAB`启用的情况下，虚拟机会为每一个线程分配一块`TLAB`空间，默认很小(`2048`)。
开启/查看：`-XX:+UseTLAB/-XX:+PrintTLAB`
指定大小：`-XX:TLABSize=?`

**考虑到逃逸分析、`TLAB`的对象分配流程**

1、通过逃逸分析，确定对象是在栈上分配内存还是在堆上分配内存，如果对象确定不逃逸，则在栈上分配内存，否则在堆上分配内存进入2

2、如果当前`TLAB`空间足够，直接在`TLAB`上分配内存，否则进入3

3、重新申请一块`TLAB`，再次尝试存放当前对象，如果失败进入4

4、申请在`Eden`区存放对象，如果内存不够，进入5

5、进行一次`Minor GC`，经过`Minor GC`后`Eden`区内存仍然不够，则将对象直接放入老年代

![对象分配流程][1]

## Chapter 2 垃圾收集器与内存分配策略 ##
栈中栈帧随着方法的进入和退出有条不紊地执行着出栈和入栈操作，每一个栈帧中分配多少内存基本上在类结构确定下来时就已知的，因此这几个内存区域的分配和回收都具有确定性，随着方法的结束或者线程结束时，内存自然就跟着回收了，而`JAVA`堆和方法区不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的

## 判断对象是否死亡 ##
**1、引用计数法**

算法如下：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加一，当引用失效时，计数器就减一，任何时候只要引用计数器值为0的对象就是不可能再被使用的。此算法的问题是难以解决对象直接相互循环引用的问题。

    public class ReferenceCountingGC {
        public Object instance = null;
        
        public static void main(String[] args) {
            ReferenceCountingGC objA = new ReferenceCountingGC();
            ReferenceCountingGC objB = new ReferenceCountingGC();
            objA.instance = objB;
            objB.isntance = objA;
            
            objA = null;
            objB = null;
            //显式  调用GC，objA和objB会被回收，但是其仍然相互引用，说明JVM并不是采用引用计数器法来判断对象是否需要被回收
            System.gc();
        }
    }
     
**2、可达性分析法**

思路：通过一系列的称为`GC Roots`的对象作为起始点，从这些节点往下搜索，搜索走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链相连(**即对象到`GC Roots`不可达**)，那么此对象就不可用，即可被`GC`回收。

在`JAVA`语言中，可以作为`GC Roots`的对象包括以下几种：

 - 虚拟机栈(栈帧中的本地变量表)中引用的对象
 - 方法区中类静态属性引用的对象(记住方法区存放的内容，类信息、常量、静态成员变量等)
 - 方法区中常量引用的对象
 - 本地方法栈中`JNI`(即`Native`)方法引用的对象

## 回收方法区 ##
方法区的垃圾收集主要回收两部分内容：**废弃常量和无用类**(同样参考方法区存放的内容)，废弃常量即没有其他任何地方引用这个字面量，而无用类的判定就比较复杂。

判断类是否为无用类：

 - 该类所有的实例都已经被回收，也就是`JAVA`堆中不存在该类的任何实例
 - 加载该类的`ClassLoader`已经被回收
 - 该类的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的任何方法
 

## 垃圾收集算法 ##
**1、标记-清除算法**

最基础的就是标记-清除算法(`Mark-Sweep`)，算法分为两个阶段：标记和清除，先标记需要回收的对象，在标记完成后统一回收所有被标记的对象。

**两个缺点**：一个是**效率问题**，标记和清除两个过程的效率都不是很高，其二是空间问题，标记清除后会产生大量不连续的**内存碎片**，空间碎片太多可能导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存不得不提前触发另一次垃圾收集。

**2、复制算法**

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存使用完毕就将其中还存活的对象复制到另一块内存中，然后把已使用过的内存空间一次性清理掉，这样就不用考虑内存碎片的问题。
现在主流虚拟机将新生代内存分割为三部分：`Eden`区域和两块`Survivor`区域(默认比例是8：1)，当回收时，将`Eden`区域和一块`Survivor`区域的存活对象复制到另一块`Survivor`区域上，只有当存活对象少于1/9时，才不会把第二块`Survivor`区域撑爆，当`Survivor`区域不够用时，需要依赖其他内存(老年代)来进行分配担保(`Handle Promotion`)。

**3、标记-整理算法**

复制算法在对象存活率较高时就要进行较多的复制操作，效率会变低，因此对于对象存活率较高的区域无法使用此算法。
根据老年代的特点，提出了标记-整理(`Mark-Compact`)算法。

**4、分代收集算法**

根据不同区域的特点采用不同的算法，新生代对象存活率较低采用复制算法， 老年代存活率较高，且没有多余空间进行分配担保，可以采用标记-清除或者标记-整理算法。

## Minor GC & Full GC ##
`Minor GC`触发条件：当`Eden`区满时，会触发`Minor GC`

`Full GC`触发条件：

 - 调用`System.gc()`方法时，系统建议执行`Full GC`，但是不必然执行
 - 老年代空间不足
 - 方法区空间不足
 - 通过`Minor GC`后进入老年代的平均大小大于老年代的可用内存
 - 分配担保时进入老年代的对象大小大于老年代的可用内存

## 垃圾收集器 ##
|名称|区域|算法|特点|缺点|
|:-:|:-:|:-:|:-:|:-:|
|`Serial`收集器|新生代|复制算法|虚拟机运行在`Client`模式下的默认新生代收集器，只有一条垃圾收集线程工作，可以和`CMS`配合工作|会`STW`(`Stop the world`)，阻塞其他所有用户线程|
|`ParNew`收集器|新生代|复制算法|有多条`GC`线程并行工作，是许多虚拟机在`Server`模式下首选的新生代收集器，可以配合`CMS`|同样会`STW`|
|`Parallel Scavenge`收集器|新生代|复制算法|可调节吞吐量(用户代码时间)/(用户代码时间+`GC`时间)，提供多个参数调节吞吐量，也被称为吞吐量优先收集器，提供自适应调节策略以达到最大的吞吐量||
|`Serial Old`收集器|老年代|标记-整理算法|只有一条`GC`线程|`STW`|
|`Parallel Old`收集器|老年代|标记-整理算法|`Paralle Scavenge`收集器的老年代版本，吞吐量优先||
|`CMS`收集器|老年代|标记-清除算法|并发收集、低停顿，适合重视服务响应速度等服务器的需求|1、并发环境下占用一部分线程(`CPU`资源)，导致应用程序变慢、总吞吐量下降 2、无法清理浮动垃圾 3、基于标记-清除算法，会产生大量内存碎片|

## 内存分配和回收策略 ##

 - 对象优先在`Eden`区域上分配内存，当`Eden`区域上没有足够空间时，虚拟机将发起一次`Minor GC`，如果`Minor GC`后`Eden`区仍然没有足够的空间，那么将通过分配担保机制(`Handle Promotion`)将对象转移到老年代中，`-XX:+PrintGCDetails`打印垃圾回收日志
 - 大对象直接进入老年代，虚拟机提供了`-XX:PretenureSizeThreshold`参数，大于该值的对象直接进入老年代，避免`Eden`区域和`Survivor`区域发生大量的内存复制
 - 长期存活的对象将进入老年代，虚拟机给每个对象定义一个年龄计数器，如果对象在`Eden`出生并经过第一次`Minor GC`后仍然存活，并且能被`Survivor`区容纳的话，将被移动到`Survivor`空间中，并且对象年龄设为1，对象每在`Survivor`区域中熬过一次`Minor GC`年龄就增加1，直到设置的阈值，就进入老年代，虚拟机提供了`-XX:MaxTenuringThreshold`参数来设置此阈值
 - 对象动态年龄判定，如果在`Survivor`区域中相同年龄的所有对象大小的总和大于`Survivor`区域的一半，年龄大于或等于该年龄的对象进入老年代

## Chapter 3 类文件结构 ##
## Class文件概述 ##
`Class`文件是一组以8字节为单位的二进制流，该文件中只有两种数据类型：**无符号数和表**。无符号数属于基本数据类型，以`u1`/`u2`/`u4`/`u8`分别代表1个字节，2个字节，4个字节，8个字节的无符号数，无符号数可以描述数字、索引引用、数量值或者按照`UTF-8`编码构成字符串值，表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表习惯性以`_info`结尾。

## 常量池 ##
常量池作为`class`类文件中重要的组成部分，主要存放两大常量：**字面常量和符号引用**，字面量即文本字符串、声明为`final`的常量值等，而符号引用则包含以下三类常量：

 - 类和接口的全限定名
 - 字段的名称和描述符
 - 方法的名称和描述符
 
在`Class`文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行时期的转换的话无法得到真正的内存入口地址，也就无法被虚拟机使用，从符号引用转化到直接引用的过程在类文件加载流程的解析过程。
常量池中总共有14种常量类型，具体参考书本`P169`页。

## Chapter 4 虚拟机类加载机制 ##
虚拟机把描述类的数据从`Class`文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的`java`类型，这就是虚拟机的类加载机制。
在`java`语言中，类的加载、连接和初始化过程都是在运行期间完成的，这就是`java`运行期动态加载和动态连接的特点。

类加载时机
-----

类加载的生命周期包括：**加载、验证、准备、解析、初始化、使用和卸载**，其中验证、准备和解析过程统称为连接过程，那么一个类在什么时候才会被虚拟机进行初始化呢：

 - 遇到`new`/`getstatic`/`putstatic`/`invokestatic`这四条字节码指令时，如果类没有初始化，那么需要对其进行初始化，对应的4种常见场景是：使用`new`实例化对象、读取或设置一个类的静态字段以及调用类的静态方法
 - 使用`java.lang.reflect`包的方法对类进行反射调用时，如果类没有初始化需要进行初始化
 - 当初始化一个类的时候，如果发现其父类没有进行初始化，先初始化其父类
 - 当虚拟机启动时，用户需要指定一个要执行的主类(包含`main()`方法的类)，虚拟机会先初始化该类
 
以上被称为**主动引用**，那么在另外一种**被动引用**情况下是不会触发类的初始化的，被动引用包括以下三种情况：
 - 通过子类引用父类的静态字段，不会触发子类的初始化
 - 通过数组来定义引用类，不会触发此类的初始化
 - 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
 
## 类加载的全程 ##
**1、加载**

在加载阶段，虚拟机需要完成三件事情：
 - 通过一个类的全限定名来获取定义此类的二进制字节流
 - 将这个字节流所代表的的静态存储结构转换为方法区的运行时数据结构
 - 在内存中生成一个代表此类的`java.lang.Class`对象，作为方法区这个类的各种数据访问入口
 
获取`class`二进制字节流：
 - 从`zip`包中读取，包括`jar`/`war`/`ear`等格式
 - 从网络中获取，这种场景最常见的就是`Applet`
 - 运行时计算生成，这种场景使用最多的就是动态代理技术，在`java.lang.reflect.Proxy`中，就是用了`ProxyGenerator.generateProxyClass`来为特定接口生成形式为`*Proxy`的代理类的二进制字节流
 - 由其他文件生成，典型场景就是`JSP`应用，即由`JSP`文件生成对应的`Class`类
 - 从数据库中读取，这种场景相对少见些，例如某些中间件服务器(如`SAP Netweaver`)
 
加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机自行定义，然后在内存中实例化一个`java.lang.Class`对象，**存放在堆中**，作为程序访问方法区中这些类型数据的外部接口

**2、验证**

**3、准备**

准备阶段为类变量(不包括实例变量)分配内存并设置类变量初始值，这里所说的初始值通常情况下是数据类型的零值，例如`boolean`类型赋值`false`等

**4、解析**

解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程，符号引用在`Class`文件中是常量池的一部分，由加载阶段可以看出，`class`文件中的静态存储结构会在该阶段转换为方法区的运行时数据结构，**可以认为class文件中的对应部分分别转换为类信息和运行时常量池组成方法区**。
符合引用和直接引用的区别：

 - 符号引用于虚拟机实现的内存布局无关，引用的目标不一定加载到内存中，符号引用的字面量形式明确定义在`class`文件中
 - 直接引用可以是直接指向目标的指针、相对偏移量或是一个能够间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的，有了直接引用，那么引用的目标必定已经在内存中存在
 
**5、初始化**

初始化阶段是执行类构造器`<clinit>()`方法的过程，`<clinit>()`方法执行过程的行为：
 - `<clinit>()`方法是由编译期自动收集类中的所有类变量的赋值动作和静态语句块(`static{}`)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句只能访问到定义在之前的变量，定义在它之后的变量只能赋值不能访问。
 - `<clinit>()`方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的构造器方法已经执行完毕，因此在虚拟机中第一个执行的`<clinit>()`方法肯定是`java.lang.Object`
 - 由于父类的`<clinit>()`方法先执行，也就意味着父类的静态语句要优于子类执行
 - `<clinit>()`方法对于类或者接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法
 - 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁、同步。

## 类加载器 ##
比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下比较才有意义，否则即使两个类来源于同一个`class`文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必定不相等。
## 双亲委派模型 ##

 - 启动类加载器(`Bootstrap ClassLoader`)：这个类加载器负责加载`%JAVA_HOME%/lib`目录下的类，使用`c++`语言辨析
 - 扩展类加载器(`Extension ClassLoader`)：这个类加载器由`sun.misc.Launcher$ExtClassLoader`实现，它负责加载`%JAVA_HOME%/lib/ext`目录中的类，或者被`java.ext.dirs`系统变量所指定的路径中的所有类库
 - 应用程序类加载器(`Application ClassLoader`)：这个类加载器是由`sun.misc.Launcher$AppClassLoader`实现，由于这个类是`ClassLoader`中的`getSystemClassLoader()`的返回值，所以一般认为它是系统类加载器，它负责加载用户类路径(`ClassPath`)上所指定的类库。
 
双亲委派模型描述了类加载器之间的层级关系，其基本流程就是：如果一个类加载器收到类加载的请求，它不会自己尝试加载，而是向上委托给父类加载器完成，每一层次的类加载器都是如此，因此所有的类加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器无法完成类加载时，才会由子类加载器去加载。


  [1]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/jvm/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B.png