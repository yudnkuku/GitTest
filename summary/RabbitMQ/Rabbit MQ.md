# Rabbit MQ

标签（空格分隔）： Rabbit MQ

---

## 1、Rabbit MQ简介 ##
`Rabbit MQ`是实现了`AMQP`(`Advanced Message Queuing Protocol`)高级消息队列协议的消息队列服务，用`Erlang`语言实现，在我们秒杀抢购商品的时候，系统会提醒我们稍等排队中， 而不是像几年之前页面卡死或者报错给用户，像这种排队结算就用到了消息队列机制，放入通道里面一个个去结算处理，而不是某个时间突然涌入大批量的查询新增把数据库给搞宕机，所以`Rabbit MQ`本质上起到的作用就是削峰填谷，为业务报价护航

## 2、工作机制 ##
在了解消息通讯之前首先了解3个概念：生产者、消费者和代理

生产者：消息的创建者，负责创建和推送数据到消息服务器

消费者：消息的接收方，用于处理数据和确认消息

代理：就是Rabbit MQ本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色

**消息发送原理**

首先应用程序和`Rabbit Server`之间会创建一个`TCP`连接，一旦`TCP`打开，并通过了认证，你的应用程序就和`Rabbit MQ`之间建立了一条信道(`Channel`)，信道是创建在真实`tcp`上的虚拟连接，`AMQP`命令都是通过信道发送出去的，每个信道都会有一个唯一的`ID`，不论是发布消息、订阅队列或者接收消息都是通过信道来完成的

**为什么不通过TCP直接发送命令**

对于操作系统来说创建和销毁`TCP`连接是非常昂贵的开销，假设高峰期每秒有成千上万条连接，每个连接都要创建一条`tcp`会话，这就造成了`tcp`连接的巨大浪费，而且系统每秒能够建立的`tcp`也是有限的，因此很快会遇到系统瓶颈

## 3、基本概念 ##

 - `Message`：消息，消息是不具名的，它由消息头和消息体组成，消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括`routing-key`(路由键)、`priority`(相对于其他消息的优先权)、`delivery-mode`(该消息可能需要持久性存储)等
 - `Publisher`消息的生产者，也是一个向交换器发布消息的客户端应用程序
 - `Exchange`：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列
 - `Binding`：绑定，用于消息队列和交换器之间的关联，一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表
 - `Queue`：消息队列，用来保存消息知道发送给消费者，它是消息的容器，也是消息的终点，一个消息可以投入一个或多个队列，消息一直在队列里面，等待消费者连接这个队列将消息取走。
 - `Connection`：网络连接，比如一个`TCP`连接
 - `Channel`：信道，多路复用连接中的一条独立的双向数据流通道，信道是建立在真实的`tcp`连接上的虚拟连接，`AMQP`命令都是通过信道发送出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成的，因为对于操作系统来说建立和销毁`tcp`连接都是非常昂贵的开销，所以引入了新到的概念，复用一条`tcp`连接(可以借鉴`nio`多路复用的思想)
 - `Consumer`：消息的消费者，表示一个从消息队列中取得消息的客户端应用程序
 - `Virtual Host`：虚拟主机，表示一批交换器、消息队列和相关对象，虚拟主机是共享相同的身份认证和加密环境的独立服务器域，每个`vhost`本质上就是一个`mini`版的`Rabbit MQ`服务器，拥有自己的队列、交换器、绑定和权限机制，`vhost`是`AMQP`概念的基础，必须在连接时指定，`Rabbit MQ`默认的`vhost`是`/`
 - `Broker`：表示消息队列服务器实体

**AMQP中的消息路由**

`AMQP`中的消息路由过程和`java`开发者熟悉的`jms`存在一些差别，`AMQP`中增加了`Exchange`和`Binding`的角色，生产者把消息发布到`Exchange`上，消息最终到达队列并被消费者接收，而`Binding`决定交换器的消息应该发送到哪个队列

**Exchange类型**

目前共有4中类型：`direct`/`fanout`/`topic`/`headers`，`headers`基本上已经不再使用了。

1、`direct`

消息中的路由键`routing key`如果和`Binding`中的`binding key`完全一致，交换器就会将消息发送到对应的队列中，它是完全匹配、单播的模式

2、`fanout`

每个发送到`fanout`类型交换器的消息都会分发到所有绑定的队列上去，`fanout`不处理路由键，只是简单地将队列绑定在交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上，`fanout`类型交换器转发消息是最快的

3、`topic`

`topic`交换器通过模式匹配分配消息的路由键属性，将路由键和绑定键进行匹配，绑定键通常包含两个通配符：`#`(匹配0或多个单词)和`*`(匹配一个单词)

## 4、Rabbit Confirm ##
如果要保证消息的可靠性，需要对消息进行持久化处理，然而消息持久化除了需要代码的设置之外，还有一个重要步骤是至关重要的，那就是保证你的消息顺利进入`Broker`(代理服务器)，这里就可以使用发送者确认模式实现。

`Confirm`发送方确认模式有三种方式实现：

 - `channel.waitForConfirms()`普通发送方确认模式
 - `channel.waitForConfirmsOrDie()`批量确认模式
 - `channel.addConfirmListener()`异步监听发送方确认模式


 
 
