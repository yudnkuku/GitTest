# 多线程

标签（空格分隔）： JAVA

---

线程
--

## 1、五种基本状态 ##
调用方法`threadObj.getState()`可以查看线程状态，线程状态是个枚举类型，分为：
1、`NEW`：新建线程，还未开始
2、`RUNNABLE`:可执行线程，表示正在`JVM`中运行，但是可能需要等待获取处理器资源
3、`BLOCKED`：处于等待监视器锁的阻塞状态(同步阻塞)
4、`WAITING`：等待其他线程执行，`wait()`和`join()`
5、`TIMED_WAITING`:等待指定的时间，如`wait(long)`、`join(long)`等
6、`TERMINATED`:完成执行
 - **新建状态**：当线程对象创建后，即进入了新建状态
 - **就绪状态**：当调用线程的`start()`方法，线程即进入就绪状态，此时并不标明线程会立马执行，而是等待`CPU`的调度，如果获得了时间片即可执行线程
 - **运行状态**：就绪状态是进入运行状态的唯一入口，此时线程处于运行状态中，也就是开始执行`run()`方法
 - **阻塞状态**：处于运行状态中的线程由于某种原因，暂时放弃对`CPU`的使用权，停止执行进入阻塞状态，根据阻塞原因，阻塞状态可以分为三种：
    1、等待阻塞：运行中的线程执行`wait()`方法，使本线程进入到等待阻塞状态
    2、同步状态：线程在获取`synchronized`同步锁失败（因为锁被其他线程占用），该线程会进入同步阻塞状态
    3、其他阻塞：通过调用线程的`sleep()`或者`join()`方法或者发出了`I/O`请求(`IO`操作一般是阻塞的，即如果线程进行了`IO`操作，那么该线程必须等待`IO`操作完成才能干别的事情)时，线程会进入阻塞状态，当`sleep()`状态超时、`join()`等待线程终止或者超时、或者`I/O`处理完毕时，线程重新进入就绪状态
    4、调用`LockSupport.park()`方法时，会使当前线程不参与线程调度，除非通过以下方式得到执行权：
    （1）其他线程调用与此线程相关的`unpark()`方法
    （2）其他线程调用了阻塞线程的`interrupt()`方法
    （3）调用虚拟返回
 - **死亡状态**：线程执行完了或者抛出异常退出了`run()`方法，该线程结束生命周期

## 2、现成的阻塞状态和控制方法 ##

 - `join()`：线程对象方法，`thread.join()`，如在`A`线程中调用`B.join()`则会阻塞`A`线程(查看`join(0`方法的源码，该方法使用了`synchronized`加锁)，调用`B`线程直到线程死亡，才会重新调用`A`线程
 - `sleep()`：让当前执行的线程暂停指定时间，并进入阻塞状态，在暂停时间内，该线程不是处于就绪状态，因此不会得到执行的机会，即使系统中没有其他的可执行的线程，该线程也不会执行，因此`sleep()`方法常被用来暂停线程执行
 - `setPriority()`：设置线程的优先级，优先级高的仅表示其具有更多的执行机会，并不一定在优先级低的线程前执行，三个优先级：`MIN_PRIORITY``NORM_PRIORITY``MAX_PRIORITY`
 - `yield()`：文档解释，提示调度器当前线程愿意放弃处理器的占用，而调度器可以自由决定是否忽略此提示

## 3、线程同步synchronized关键字的用法 ##
`synchronized`是`java`中的关键字，是一种同步锁，，他修饰的对象有以下几种：

 - 修饰一个代码块，被修饰的代码块称为同步代码块，同步的作用域是对象，通常有如下几种写法：

    synchronized(this){}    //这和修饰方法是等价的
    synchronized(obj){} //A线程访问该代码块时，会拿到obj对象的锁，其他线程就无法访问该代码块
    synchronized(new byte[0]){}

 - 修饰一个方法，被修饰的方法称为同步方法，其作用域是整个方法，作用的对象是调用这个方法的对象
    public synchronized void run() {}

 - 修饰一个静态方法，其作用域是整个静态方法，作用对象是这个类的所有对象
    public synchronized static void method() {}

 - 修饰一个类，其作用范围是括号里的代码，作用对象是这个类的所有对象
    public void method() {
        synchronized(this.getClass()){}
    }

## Thread源码分析 ##
`join`方法是一个对象方法，通常在某线程`thread1`中通过`thread2.join()`方法强行让`thread1`等待直到`thread2`执行完，内部是通过`wait()`方法来实现的，因此在分析`join()`方法的实现原理前必须先了解`wait()`方法，`wait()`方法是`Object`的对象方法，它会使当前线程释放掉对象锁进入等待阻塞状态，直到调用`notify()`或者`notifyAll()`方法唤醒等待该对象锁的线程，并且重新通过竞争机制获取对象锁后才能返回，并恢复线程执行。`join()`方法源码如下：

    //签名使用synchronized关键字，表明当前执行线程(主线程)已经获取该线程对象thread(调用join方法的thread对象)的对象锁
    public final synchronized void join(long millis) 
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) { //如果thread还未销毁，则主线程继续阻塞
                wait(0);    //主线程释放thread对象锁，并进入等待阻塞状态，直到thread线程执行完，主线程重新拿到thread对象锁
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }

`sleep()`方法源码如下：
    
    //文档解释：使当前线程休眠一段时间(停止执行)，但此时该线程并没有释放掉对象锁
     public static native void sleep(long millis) throws InterruptedException;

## 线程中断机制 ##
线程的`Thread.interrupt()`方法会设置该线程的中断标志位，设置完标志位之后的线程是死亡、等待新的任务或是运行至下一步就取决于程序本身。
调用线程的`Thread.interrupt()`方法如果发生以下三种情况，会抛出异常：
1、如果线程在调用`wait()/wait(timeout)/join()/join(timeout)/sleep()/sleep(timeout)`等方法后处于阻塞状态，并且在此阻塞状态有其他线程调用该阻塞线程的`interrupt()`方法会直接抛出`InterruptedException`，线程中断标志位被清除，阻塞线程会被唤醒。
2、如果线程在`InterruptibleChannel`上执行了`IO`操作而阻塞，那么中断之后`channel`将被关闭，线程中断标志位被设置，并且会抛出`ClosedByInterruptException`异常
3、如果线程在`Selector`中被阻塞(`Selector.select()`)，线程中断标志会被设置，并且阻塞方法会立即返回，这和`Selector.wakeup()`方法类似

如果上述三种情况均为发生，那么线程的中断标志位将被设置。

其他线程中断相关方法：
1、`isInterrupted()`：实例方法，判断线程是否被中断，不会影响线程的中断标志。
2、`interrupted()`:静态方法，判断线程是否被中断，并清除其中断状态，如果连续两次调用`interrupted()`方法，第二次方法返回`false`，除非在第一次调用之后，第二次调用之前其他线程再次调用了`interrupt()`方法中断线程。

假如线程在阻塞状态下被中断，会立即抛出`InterruptedException`异常，并唤醒阻塞线程，同时清除中断标志位，但是`synchronized`在获取锁的过程中是不能被中断的，意思是如果产生了死锁，则不可能被中断。
没有任何语言方面的需求一个被中断的线程应该终止，中断一个线程只是给线程发起了一个中断请求，设置中断标志位，而被中断线程具体如果处理中断可以自行决定：

    public void run() {
        try {
            while(!Thread.currentThread().isInterrupted() && other conditions) {
                do some work
            }
        } catch(InterruptedException e) {
            //线程可能在阻塞过程中被中断
        } finally {
            //线程结束前做一些清理工作
        }
    }

使用`thread.interrupt()`中断阻塞状态线程：
    当线程处于阻塞状态时(如调用`sleep`、`wait`、`join`等方法)，调用阻塞线程的`interrupt`方法会使阻塞线程结束阻塞状态，并抛出`InterruptedException`异常，
其中断标志也会被清除，相当于调用线程给阻塞线程发送了一个中断请求，阻塞线程如何处理这个中断请求可以自定义：

    class Example3 extends Thread {
         public static void main(String args[]) throws Exception {
             Example3 thread = new Example3();
             System.out.println("Starting thread...");
             thread.start();
             Thread.sleep(3000);
             System.out.println("Asking thread to stop...");
             thread.interrupt();// 等中断信号量设置后再调用
             Thread.sleep(3000);
             System.out.println("Stopping application...");
         }

 
     public void run() {
         while (!Thread.currentThread().isInterrupted()) {
             System.out.println("Thread running...");
             try {
                 /*
                  * 如果线程阻塞，将不会去检查中断信号量stop变量，所 以thread.interrupt()
                  * 会使阻塞线程从阻塞的地方抛出异常，让阻塞线程从阻塞状态逃离出来，并
                  * 进行异常块进行 相应的处理
                  */
                 Thread.sleep(1000);// 线程阻塞，如果线程收到中断操作信号将抛出InterrptedException异常
             } catch (InterruptedException e) {
                 System.out.println("Thread interrupted...");
                 /*
                  * 如果线程在调用 Object.wait()方法，或者该类的 join() 、sleep()方法
                  * 过程中受阻，则其中断状态将被清除
                  */
                 System.out.println(this.isInterrupted());// false
 
                 //中断线程，退出上面的while循环
                 Thread.currentThread().interrupt();
             }
         }
         System.out.println("Thread exiting under request...");
     }
     }

## 死锁Deadlock ##
死锁的定义：
两个线程互相持有对方需要的锁，比如线程`A`持有锁`M`想要锁`N`，而线程`B`持有锁`N`想要锁`M`，这样就可能出现死锁情况
出现死锁后，可以先`jps`查看进程`ID`，再使用`jstack`查看死锁堆栈信息，可用`taskkill pid`杀死死锁进程

## volatile关键字 ##
几个概念：内存、工作内存(高速缓存)、原子性、可见性、有序性

**可见性**：普通共享变量被修改之后，什么时候被写入内存是不确定的，当其他线程在修改和写入内存之间去读取时，此时内存中还是原来的旧值，这就可能导致修改的不可见性，`volatile`关键字可以保证**值读取**可见性(整个值读取过程没有被打断，如果被打断就是`volatile`无法保证原子性的原因)，修改变量后立即将工作内存中的值刷入主存中，并使其他线程工作内存对应的缓存行无效，直接从主存中拿值。

**原子性**：在`Java`中，对基本类型的变量的赋值是原子性的，即这些操作是不可被中断的，要么执行，要么不执行
`volatile`**保证了变量的可见性**，即它会保证修改的值立即更新到主存中，当其他线程需要时直接去内存中读取新值，**但无法保证所有操作的原子性**
`volatile`为什么会保证可见性：这里就要提到内存屏障(`memory barrier`)，内存屏障是一个`CPU`指令，它可以**a)**确保一些特定操作执行的顺序**b)**影响一些数据的可见性，可以强制更新内存。所以对于`volatile`字段，`jvm`会在写操作后面插入一个写屏障指令，在读操作前插入一个读屏障指令，这样可以保证更新的值刷新至内存，举个例子：

    例如一个volatile的Integer自增操作其实要分为三步：1)读取变量到缓存中2)增加变量的值3)把缓存中的值写入内存让其他线程可见(最后一步是内存屏障)
    Load->Increment->Store->StoreLoad Barrier
内存屏障提供三个功能：
1)确保指令重排序时不会把后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面，即保证之前的操作全部完成
2)会强制将缓存中的修改刷入内存
3)如果是写操作，会导致其他CPU中对应的缓存行无效

`synchronized`和`Lock`也可以保证可见性，它们保证同一时刻只有一个线程能够拿到锁并执行同步代码，并且在释放锁之前将变量的修改刷新到主存中
原子性操作：简单的读取、赋值才是原子性操作
`volatile`无法保证原子性的原因：同样，以`volatile`修饰的变量自增为例`i++`，设`i`的初始值为10，假如线程1对变量进行自增操作，执行第一步`Load`从内存中读取`i`，然后线程1被阻塞了，接着线程2对变量进行自增操作，线程2也去内存中读取变量的值，此时`i`的值仍为10，然后执行自增操作，写入内存，然后线程1恢复运行，由于此时线程1已经读取了`i`的值10(这里为什么线程1缓存行无效，但是线程1读取操作已经进行，直接从缓存中拿值)，自增并写入内存，最后2个线程分别执行自增操作后，内存中`i`的值为11，这显然出现了线程不安全，原因在于自增操作不是原子性操作，而`volatile`无法保证操作的原子性

对于普通变量：读操作会优先读取工作内存的数据，如果工作内存中不存在，则从主存中拷贝一份数据到工作内存中，写操作会将值写入工作内存，但什么时候刷入主存是未知的
对于`volatile`变量：读操作时`JVM`会把工作内存中的缓存行设为无效，要求线程从主内存中读取数据，写操作时`JVM`会把工作内存中对应的数据刷新到主存中，这种情况下其它线程就可以读取变量的最新值
**java中的原子操作**：
 - 基本类型赋值，除了`long`和`double`(8字节，64位，对于64位操作系统是原子操作，而对于32位操作系统则不是，会先赋值前32位，再赋值后32位，这样会导致线程不安全)
 - 引用赋值
 - `java.concurrent.Atomic*`类的所有操作
 - `volatile`关键字的`long `和`double`赋值(`volatile`本身并不能保证操作的原子性，但`jvm`能保证`long `和`double`的读写操作是原子性的)

**乐观锁和悲观锁**
`java`在`jdk1.5`之前都是靠`synchronized`关键字来保证同步的，如果出现多个线程同时访问锁，那除了拿到锁的线程之外所有的线程都将被挂起，当锁线程执行完毕后，其他线程才能恢复执行，在挂起和恢复执行的过程中存在着很大的开销，锁还存在一些缺点，当一个线程正在等待锁时，它不能做任何事，如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去，如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转(`Priority Inversion`)

独占锁是一种悲观锁，`synchronized`就是一种**独占锁**，他只有确保其他线程不会造成干扰的情况下执行，会导致其他所有需要锁的线程挂起，等待有锁的线程释放锁，而另一个更加有效的锁就是乐观锁，所谓**乐观锁**就是线程在使用数据时，乐观地认为不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入，如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作(例如报错或者自动重试)

**悲观锁适合写操作多**的场景，先加锁以保证写操作的正确性

**乐观锁适合读操作**的场景，不加锁的特点使其读操作性能大幅提升

**CAS无锁算法**
要实现无锁(`lock-free`)的非阻塞算法有很多实现方法，其中`CAS`(比较和交换，`compare and swap`)是一种有名的无锁算法，`CAS`是一个`CPU`指令，在大多数处理器架构中，都采用了`CAS`指令，它的语义是:

    我认为V的值是A，如果是那么将V值更新为B，否则不修改并告诉V的实际值是多少

`CAS`是一种乐观锁技术，当多个线程尝试使用`CAS`同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程不会被挂起，而是被告知失败并可以再次尝试，`CAS`有三个操作数，内存值`V`，旧的预期值`A`以及要修改的新值`B`，当且仅当预期值`A`和内存值`V`相同时，才会将内存值更新为`B`，否则什么都不做，其`C`算法如下：

    int compare_and_swap (int* reg, int oldval, int newval) 
    {
      ATOMIC();
      int old_reg_val = *reg;
      if (old_reg_val == oldval) 
         *reg = newval;
      END_ATOMIC();
      return old_reg_val;
    }

`CAS`存在常见的`ABA`问题，通常可以通过增加版本号来解决，例如`AtomicStampedReference`
另外，循环时间长，开销比较大，如果并发量相当高，`CAS`操作长时间不成功，会导致其一直自旋，带来`CPU`消耗

## 双重检查锁定(Double Checked Locking) ##


    public class DoubleCheckedSingleton {

        //必须使用volatile关键字，禁止指令重排序
        private volatile static DoubleCheckedSingleton instance = null;
    
        public DoubleCheckedSingleton() {
        }
    
        public static DoubleCheckedSingleton getInstance() {
            if (instance == null) { //多线程情况下此处可能会拿到instance还没有实例化完全的实例
                synchronized (DoubleCheckedSingleton.class) {
                    if (instance == null) {
                        instance = new DoubleCheckedSingleton();    //new操作实际上分为三步，分配内存、实例化对象，将instance指向该内存，这三条操作可能会重排序
                    }
                }
            }
            return instance;
        }
    }
    
    
## Executor框架 ##
在`java.util.concurrent`包下，引入了`Executor`框架，其内部使用了线程池机制，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此在`Java 5`之后，通过`Executor`来启动线程比使用`Thread`的`start()`方法来启动线程更好，除了易于管理、效率更高(用线程池实现，节约开销)外，还有关键的一点，避免`this`逃逸问题。
`Executor`框架包括：线程池、`Executor`、`Executors`、`ExecutorService`、`CompletionService`、`Future`、`Callable`等

 - `Executor`接口：用于提交`Runnable`任务，提供了诸多方法将任务提交和任务执行解耦，包括线程使用、调用等细节。
一段简单的代码：


    Executor executor = anExecutor;
    executor.execute(new RunnableTask1());
    executor.execute(new RunnableTask2());
    
然而，`Executor`并不是只能异步执行任务，同样可以在调用线程中立即执行提交的任务：

    class DirectExecutor implements Executor {
        public void execute(Runnable r) {
            r.run();
        }
    }
同样，该任务也可以在其他线程中执行：

    class ThreadPerTaskExecutor implements Executor {
        public void execute(Runnable r) {
            new Thread(r)
        }
    } 

`Executor`提供的方法：

    public interface Executor {
        void execute(Runnable command);
    }

 - `ExecutorService`接口：继承自`Executor`接口，提供了管理`Executor`生命周期的方法，并且通过`Future`接口跟踪一个或者多个异步任务执行的过程。
`ExecutorService`能够被终止(`shutdown`)，终止后，无法继续接受新的任务，有两个`shutdown`方法：
1、`shutdown()`：停止接收新的任务，这个方法不会等待之前提交的任务完成执行，调用`awaitTermination()`方法来完成所有提交的任务执行。
2、`shutdownNow()`：不会执行还未执行的任务，并且强制停止当前正在执行的任务。
`Executor`一旦停止，就没有任务正在执行，没有任务等待执行，没有任务能够被提交，没有使用的`ExecutorService`应该关闭释放资源。
`submit()`方法重载了父类的方法，返回`Future`实例，可以用来取消执行或者等待执行完成，`invokeAny`方法当任何一个任务执行成功后返回`Future`实例，`invokeAll`方法执行批量任务，当所有任务都执行完毕后返回`Future`实例`List`

其他方法：
1、`awaitTermination(timeout, unit)`:在`shutdown`请求之后等待所有的任务执行完毕直到超时限制或者当前线程被中断，终止返回`true`，如下方法展示了如何关闭：

        void shutdownAndAwaitTermination(ExecutorService pool) {
            pool.shutdown(); // Disable new tasks from being submitted
            try {
                // Wait a while for existing tasks to terminate
                if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {
                    pool.shutdownNow(); // Cancel currently executing tasks
                    // Wait a while for tasks to respond to being cancelled
                    if (!pool.awaitTermination(60, TimeUnit.SECONDS))
                        System.err.println("Pool did not terminate");
                }
            } catch (InterruptedException ie) {
                // (Re-)Cancel if current thread also interrupted
                pool.shutdownNow();
                // Preserve interrupt status
                Thread.currentThread().interrupt();
            }
        }

2、`isShutdown()`：是否关闭
3、`isTerminated()`:在接收到`shutdown`或者`shutdownNow`请求后是否执行完所有的任务

 - `Executors`类：提供了大量的工厂和工具类方法用于创建线程池，返回的线程池都实现了`ExecutorService`接口

下面简要介绍下`Executors`类中创建线程池的静态方法，首先介绍下`ThreadPoolExecutor`的构造方法：

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
    
参数定义：

 - `corePoolSize`:核心线程数量，指的是线程池中最少线程的数量，即使它们是空闲`idle`的，也不会被移出线程池
 - `maximumPoolSize`:最大线程数量
 - `keepAliveTime`:当**线程池中线程数量大于核心线程数量时**，这个参数表示多余的空闲线程等待新任务的最大时间，否则将被终止，如果线程池中线程数量小于核心线程数量，这个参数没用
 - `unit`：`keepAliveTime`的时间单位
 - `workQueue`:任务执行前保存他们的队列，这个队列只会保存`execute`方法提交的`Runnable`任务
 - `threadFactory`:创建线程的线程工厂，默认是`Executors.defaultThreadFactory()`返回的`DefaultThreadFactory`
 - `handler`:当达到线程池中线程数量达到`maximumPoolSize`并且队列已满时的任务处理器，有四种实现方式，默认是`AbortPolicy`，直接抛出`RejectedExecutionException`异常

接着看一下`Executors`提供的静态方法：

 - 创建固定数量线程的线程池：

        public static ExecutorService newFixedThreadPool(int nThreads) {
            return new ThreadPoolExecutor(nThreads, nThreads,
                                          0L, TimeUnit.MILLISECONDS,
                                          new LinkedBlockingQueue<Runnable>());
        }

设置了`corePoolSize=maximumPoolSize=nThreads`，`keepAliveTime=0`，任务队列选用的是**无边界**的`LinkedBlockingQueue`，可以看出该线程池具有以下特性：线程池中最多会存在`nThreads`个线程，每来一个新任务，如果线程池中线程数量小于`nThreads`，那么会新建线程执行该任务，否则任务进入队列，等待空闲线程

 - 创建缓存性线程池：

        public static ExecutorService newCachedThreadPool() {
            return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
                                      }

参数分别为`0,Integer.MAX_VALUE,60`,核心线程池数量`corePoolSize=0`，最大线程数量`maximumPoolSize=Integer.MAX_VALUE`，线程存活`keepAliveTime=60s`，任务队列选用的是`SynchronousQueue`，该队列会将任务直接交给线程执行，会直接`reuse`池子中空闲的线程，如果所有的线程都是忙碌状态，会新建一个新的线程放入池中，缓存性线程池通常用于执行生存期很短的异步型任务，空闲线程的`idle`时间为60秒，在时间之内的线程可以被`reuse`，否则将被移出线程池

 - 创建单例线程：

        public static ExecutorService newSingleThreadExecutor() {
            return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
                                    }
参数分别为：`1,1,0`,底层池和固定池、缓存池一样，单例池中只有一个线程，任务队列也是**接近无**限的队列

 - 创建调度型线程池：
 

        public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
            return new ScheduledThreadPoolExecutor(corePoolSize);
        }
这个池子里的线程可以按`schedule`依次`delay`执行，或周期执行

阿里巴巴`Java`规范有一点建议：

    线程池最好不要使用Executors来创建，而是通过ThreadPoolExecutor来构造，这样的处理方式可以更加明确线程池的运行规则，规避资源耗尽的风险。Executors返回的线程池对象弊端如下：
    1）FixedThreadPool和SingleThreadPool：允许任务队列长度为Integer.MAX_VALUE，可能会堆积大量请求任务，导致OOM
    2）CacheThreadPool和ScheduledThreadPool：允许创建线程数量为Integer.MAX_VALUE，可能会创建大量线程，从而导致OOM

**Callable接口**
在`Java`中，任务分为两类，一类是`Runnable`，一类是`Callable`接口，两者都可以被`ExecutorService`执行，但是`Callable`有返回值而`Runnable`没有，可以查看`ExecutorService`接口中的方法对比：

 - `<T> Future<T> submit(Callable<T> task)`:提交`Callable`任务，并返回`Future`对象，通过`Future`对象的`get()`方法获取计算结果

**Future接口** 
`Future`接口表示异步计算的结果，该接口提供了检查计算是否完成、阻塞获取结果的方法，`ExecutorService`中的`submit`方法就可以提交异步任务，返回`Future`实例。
方法列表：

    public interface Future<V> {
    boolean cancel(boolean var1);   //取消任务执行

    boolean isCancelled();  //在任务完成之前是否被取消是否被取消

    boolean isDone();   //任务是否完成，终止、异常或者取消都会返回true

    V get() throws InterruptedException, ExecutionException; //等待任务执行完毕，返回结果

    V get(long var1, TimeUnit var3) throws InterruptedException, ExecutionException, TimeoutException;   //等待超时时间获取任务执行结果，如果超时任务还没执行完成，会抛出TimeoutException
    }

**ThreadPoolExecutor**
    实现了`ExecutorService`接口，使用线程池中的线程来执行提交的任务，通常可以通过`Executors`提供的工厂方法来配置线程池。
    线程池在执行大量的异步任务时效率很高，并且提供了一系列管理线程资源的手段，同时还实现了一些基本统计，例如已完成任务的数量。
    线程池会根据设置的`corePoolSize`和`maximumPoolSize`来调整池中线程的数量，当一个新的任务提交进来时，如果少于`corePoolSize`数量的线程在运行，那么会创建一个新的线程处理任务，即使有工作线程闲置，如果线程数量大于`corePoolSize`小于`maximumPoolSize`，只有当队列满时才会创建新的线程，如果设置`corePoolSize=maximumPoolSize`，相当于创建了一个固定大小的线程池，一般的这两个参数在构造期间就指定，也可以在运行期间通过方法动态改变。
    默认情况下，核心线程会初始化创建，当任务达到时才会`start`，这可以通过调用`prestartCoreThread()`或者`prestartAllCoreThreads`方法动态调整。
    线程池中的线程默认是通过`ThreadFactory`创建，通常使用`Executors.defaultThreadFactory`。
    如果线程池中线程数量大于核心线程数量，超过的线程如果空闲时间超过了`keepAliveTime`，那么该线程会被终止，这可以有效的减少资源消耗。

**任务入队操作**：
1、如果线程数量小于核心线程数量，那么线程池会优先创建新的线程，而不会将任务入队
2、如果线程数量大于核心线程数量，那么会优先将任务而不是创建新的线程
3、如果任务无法入队(队列满了)，那么会创建新的线程，除非线程数量超过了最大线程数量限制，否则该任务将被线程池拒绝

**队列实现有多种策略**：
1、`Direct handoffs`，例如`SynchronousQueue`同步队列，当任务到达时不会入队而是直接开启线程执行任务，这通常适用于无边界线程池。
2、无界队列，例如`LinkedBlockingQueue`，当所有的核心线程都在忙着执行任务时，新来的任务会被入队等待，此时线程池中的线程数量永远无法大于核心线程数量
3、有界队列，例如`ArrayBlockingQueue`，当使用有限的最大线程池数量时，能够阻止资源的消耗，但是可能更难去调节和控制，队大小和最大线程数量会互相限制，使用大的队列和小的线程池可以减少`CPU`消耗、系统资源和上线文切换，但是可能导致较低的吞吐量。

**拒绝任务**：
    新任务提交时，如果`Executor`关闭，那么该任务会被拒绝，或者当线程池具备有限的最大线程数量和工作队列容量，当工作队列和线程池中线程数量饱和时，新来的任务也可能被拒绝，这个时候会调用`RejectedExecutionHandler`的`rejectedExecution`方法，线程池提供了4种拒绝策略：
    1、默认`ThreadPoolExecutor.AbortPolicy`，会抛出`RejectedExecutionException`运行时异常。
    2、`ThreadPoolExecutor.CallerRunsPolicy`，由调用线程执行任务，提供了一种简单的反馈控制机制，可以减慢新任务提交的速率。
    3、`ThreadPoolExecutor.DiscardPolicy`，直接将任务丢弃。
    4、`ThreadPoolExecutor.DiscardOldestPolicy`，会将队列开头的任务出列并丢弃，然后重新`execute`当前任务，如果再次失败则再次执行此策略重复。
    
## ReentrantLock实现机制、AQS源码分析 ##
`AQS`通过`FIFO`等待队列实现了阻塞锁和相关的同步器，内部通过一个`volatile`类型的状态变量`state`来表征锁占用状态，并且提供了针对该`state`的`CAS`修改方法，当`state`为0时，表示没有线程占有锁，当`state=1`时表示锁被占用，`state>1`时表示锁被同个线程重入，当线程释放锁时，释放一次`state-1`。`AQS`还在内部定义了一个`Node`类表示等待队列上的节点类，该队列实际上是一个`CLH`锁队列，可以查看`Node`类的定义，其中定义了4个成员变量`prev`/`next`/`waitStatus`/`thread`分别表示前驱节点、后继节点、等待状态和该节点代表的线程(该队列是所有等待锁的线程的阻塞队列，首节点是一个空节点，具体可以查看方法`enq(Node node)`源码),`waitStatus`分为5种状态：
 - `SIGNAL(-1)`:表示后继节点正在被阻塞(通过`park()`方法)，因此在该节点释放锁或者变为取消状态时必须`unpark`其后继节点
 - `CANCELLED(1)`:唯一大于0的状态值，表示该节点由于超时或者中断变为取消状态，取消的节点不会变更状态，特别是取消状态的节点不会再次阻塞
 - `CONDITION(-2)`:该节点目前在一个条件队列上，节点的线程在等待`Condition`，当其他线程调用`Condition`的`signal`方法后，当其状态变量变为0时才会被转换为同步队列节点
 - `PROPAGATE(-3)`:共享释放会被传递到其他节点
 - 0：其他状态

`AQS`源码解析：
    
    public final void acquire(int arg) {
        //线程尝试获取锁
        if (!tryAcquire(arg) &&
            //如果获取失败，则将该线程封装成独占节点加入同步队列尾部，再从队列中获取
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }

`FairSync`中的`tryAcquire()`实现：

        //当前线程尝试获取锁
    protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            //如果state变量为0，表示当前没有线程占用锁
            if (c == 0) {   
                //hasQ...判断是否有其他线程也在等待锁
                if (!hasQueuedPredecessors() &&
                    //CAS设置state为acquires
                    compareAndSetState(0, acquires)) {
                    //设置当前线程为独占线程
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            //当前线程为独占线程，这里表示当前线程重复拿到锁，重入
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
    }
如果`tryAcquire()`获取锁失败，那么通过`addWaiter()`将当前线程封装成`Node`节点放入同步队列队尾，然后调用`acquireQueued()`从队列中获取

    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            //死循环
            for (;;) {
                //获取node的前置节点
                final Node p = node.predecessor();
                //如果前置节点是头结点并且tryAcquire成功
                if (p == head && tryAcquire(arg)) {
                    //将node设为头结点，node的前置节点出列并被GC回收
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                //node的前置节点不是head节点或者tryAcquire失败，调用shouldPark...方法判断是否需要阻塞，如果是则调用LockSupport.park()方法阻塞线程
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
    
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        //获取node前置节点状态
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            //前置节点状态是SIGNAL，直接返回true，表示当前节点即将要block
            return true;
        if (ws > 0) {
            //如果前置节点状态>0，即为CANCLE状态，那么跳过所有CANCLE状态节点
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            //前置节点状态为其他状态，如PROPAGATE或者0，那么CAS设置前置节点状态为Node.SIGNAL
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }

**公平锁和非公平锁**
`FairSync`：

    final void lock() {
            acquire(1); //获取一次锁，将state变量+1
        }
    tryAcquire()源码见上，大致流程如下：
    1、如果state=0，表明没有线程占用锁，那么如果当前线程Node没有前置节点，并且通过CAS设置state成功，那么将当前线程设置为独占线程，拥有锁，并返回true，表明尝试获取锁成功
    2、如果state非0，且当前线程就是独占线程(拥有锁的线程)，那么直接设置state，并返回true
    3、否则返回false

`NonFairSync`：

    final void lock() {
            if (compareAndSetState(0, 1))
            //CAS设置state值，成功则将当前线程设置为独占线程 setExclusiveOwnerThread(Thread.currentThread());
            else
            //正常获取锁流程，调用父类AQS的acquire()方法
                acquire(1);
        }
        
    protected final boolean tryAcquire(int acquires) {
            //调用非公平获取锁方法
            return nonfairTryAcquire(acquires);
        }
        
    final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
            //state=0，并且CAS设置state成功，那么直接设置当前线程为独占线程，不会考虑之前是否有其他线程在等待，这就是非公平锁
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
            //如果当前线程是独占线程，则直接设置state
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }

## ConditionObject源码分析 ##
`ConditionObject`实现了`Condition`接口，其维护了两个队列：

 - `condition`等待队列：该队列中所有`Node`的`waitStatus=Node.CONDITION`，具有两个属性节点`firstWaiter`和`lastWaiter`分别表示`condition`队列的首节点和末节点
 - `sync`同步队列：参考`enq()`源码

`await()`方法源码：

    public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
            //将当前线程封装成CONDITION状态节点加入condition队列尾部
            Node node = addConditionWaiter();
            //返回到上一次同步状态
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            //如果该节点不在同步队列上，则进入while循环
            while (!isOnSyncQueue(node)) {
                //将当前线程挂起
                LockSupport.park(this);
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }

`addConditionWaiter()`方法源码：

    private Node addConditionWaiter() {
            Node t = lastWaiter;
            //如果尾节点waitStatus不是CONDITION
            if (t != null && t.waitStatus != Node.CONDITION) {
                //清除所有CANCEL节点
                unlinkCancelledWaiters();
                //更新t节点
                t = lastWaiter;
            }
            Node node = new Node(Thread.currentThread(), Node.CONDITION);
            if (t == null)
                firstWaiter = node;
            else
                t.nextWaiter = node;
            lastWaiter = node;
            return node;
        }

`unlinkCancelledWaiters()`源码：
   

     //从头遍历condition队列，去除掉所有非CONDITION状态的节点，即最后所有节点状态全部变成CONDITION
        private void unlinkCancelledWaiters() {
                Node t = firstWaiter;
                //已经遍历完成的子队列的尾节点，该队列中所有节点状态都是CONDITION
                Node trail = null;
                while (t != null) {
                    Node next = t.nextWaiter;
                    if (t.waitStatus != Node.CONDITION) {
                        t.nextWaiter = null;
                        if (trail == null)
                        //将next设置为firstWaiter
                            firstWaiter = next;
                        else
                            //将trail的下一个节点设置为next
                            trail.nextWaiter = next;
                        if (next == null)
                        //没有更多的节点，更新lastWaiter为trail，这个也可以放到循环外面更新
                            lastWaiter = trail;
                    }
                    else
                //当前节点状态CONDITION，则将其设置为trail
                        trail = t;
                    //更新t节点
                    t = next;
                }
            }

`signal()`源码：

    public final void signal() {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            if (first != null)
                //调用doSignal()方法
                doSignal(first);
        }

`doSignal()`源码：

    //从队首开始移除CANCEL节点，将非CANCEL节点transfer到sync队列
    private void doSignal(Node first) {
            do {
            //更新firstWaiter节点，因为之前的节点状态都被CANCEL，无法更改状态，需要从队列头部去掉这些节点
                if ( (firstWaiter = first.nextWaiter) == null)
                    //没有多余节点，将lastW
                    lastWaiter = null;
                //first节点无法transfer，从队列中去掉之
                first.nextWaiter = null;
            } while (!transferForSignal(first) &&
                     (first = firstWaiter) != null);
        }
        
    //等价于
    do {
        firstWaiter = first.nextWaiter;
        if (firstWaiter == null)
            lastWaiter = null;
        first.nextWaiter = null;
        first = firstWaiter;
    } while (!transferForSignal(first) && first != null)

`transferForSignal()`源码：

    final boolean transferForSignal(Node node) {
        /*
         * If cannot change waitStatus, the node has been cancelled.
         */
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;

        /*
         * Splice onto queue and try to set waitStatus of predecessor to
         * indicate that thread is (probably) waiting. If cancelled or
         * attempt to set waitStatus fails, wake up to resync (in which
         * case the waitStatus can be transiently and harmlessly wrong).
         */
        Node p = enq(node);
        int ws = p.waitStatus;
        if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }


## 详解Object类wait()和notify()方法 ##
先看看文档中`wait(timeout)`方法的解释：

        造成当前线程的阻塞，直到其他线程调用此对象的notify()或者notifyAll()方法。当前线程必须拥有此对象的锁，调用wait方法会使当前线程释放该对象的锁，并且进入等待阻塞状态(加入条件队列，等待重新拿到对象锁，等待状态中的线程不会参与线程调度)，直到发生如下四种事情：
    1、其他线程调用该对象的notify()方法，并且阻塞线程刚好通过竞争机制获取到该对象锁，就可以被唤醒
    2、其它线程通过调用该对象的notifyAll()方法，阻塞线程会被唤醒
    3、其他线程调用Thread.interrupt()方法中断阻塞线程
    4、超时时间结束，如果timeout=0，那么不会考虑超时时间知道线程被唤醒
    如果发生上述四种情况，那么阻塞线程就会从条件队列移除，并重新参与线程调度，和其他线程竞争对象锁，处于等待阻塞状态中的线程如果重新拿到对象锁就可以恢复到wait导致的阻塞之前的状态并恢复执行(即从wait方法返回)。该方法只能在拥有对象锁的线程中调用，并且最好在while循环中以避免其他线程的中断或者虚拟唤醒，例如:
        //synchronized(obj)获取obj的Object Monitor
        synchronized(obj) {
            while(condition) {
                obj.wait();
                ...//somecode
            }
        }

    当某线程拿到对象锁后，在同步代码块中执行该对象的`wait()`方法，会使该线程暂时释放对象锁进入等待阻塞状态，处于阻塞状态的线程不会参与线程调度，当某线程获取对象锁并调用`notify()/notifyAll()`方法之后，处于阻塞状态的线程会重新进入可执行状态，并参与线程调度，如果再次获得对象锁，**将会从原来阻塞的位置继续执行代码**，如上面的`somecode`写在`obj.wait()`之后，当阻塞线程恢复执行，该代码会立即执行

`notify()`的文档解释：

    唤醒等待对象锁的某个线程，线程选择是任意和随机的，通过调用对象的wait()方法可以使线程进入等待阻塞状态。唤醒的线程只有在当前线程释放对象锁时才能执行，并且会和其他线程竞争对象锁。该方法只能在拥有对象锁的线程内调用，一个线程获取对象锁(Object Monitor)有三种方式：
    1)执行synchronized method()方法
    2)执行synchronized(obj){}包含的代码段
    3)执行synchronized(Object.class){}代码段或者执行某类的synchronized静态方法:synchronized static method()
    同一时刻，只有一个线程能拥有对象的锁，因此synchronized也叫做独占锁，悲观锁，当某线程拥有该对象锁时，其他需要获取该对象锁的线程只能等待，但是可以访问其他非同步方法

## Lock锁 ##
这里主要介绍两个接口`Lock`和`Condition`
**`Lock`**：
锁实现提供了更多可拓展性的锁操作，支持多个关联的`Condition`对象。锁对象实际上是控制多线程访问共享对象的工具，一般地，锁对象提供了共享资源的排他性访问，在同一时刻只有一个线程能够获取锁，其他所有访问共享资源的线程必须先获取锁再访问资源，然而，某些锁允许并发访问，例如读锁`ReadWriteLock`。
`synchornized`方法或者代码段提供了与对象相关的隐式对象锁
`Lock`接口提供的方法：
`lock()`：获取锁
`newCondition()`：返回与`Lock`对象绑定的`Condition`实例，在等待该`Condition`之前，当前线程必须获取该锁对象，即先调用`lock.lock()`再去调用`condition.await()`，**调用`await()`方法会在进入等待阻塞状态前释放掉锁，并且在`await`返回前重新获取锁**

**`Condition`**:
`Condition`接口将`Object`类的`wait/notify`方法析出到单独的对象中，和任意的`Lock`实现结合，`Lock`替换了`synchronized`方法和代码段，`Condition`用`await/signal`方法替换了对象的监视器方法`wait/notify`，等待一个`Condition`的一个关键属性就是它会**自动释放相关的锁并将当前线程挂起**，和`Object`的`wait()`方法一样
`Condition`对象和`Lock`对象绑定，直接用`lock.newCondition()`方法获取`Condition`对象
举个简单的例子，假设有个缓存区支持读写操作：`take`和`put`方法，如果缓存区为空，读线程就会被阻塞，如果缓存区已满，写线程就会被阻塞，每次当缓存区非空或者可取时，我们仅仅唤醒一个对应的线程，这是一种比较优化的方式：

    package demo.conpro;
    
    import java.util.concurrent.locks.Condition;
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;

    /**
     * 具有阻塞功能的缓存区，当缓存区为空时，阻塞读线程，当缓存区满时，阻塞写线程
     */
    public class BoundedBuffer {

    //锁对象
    private final Lock lock = new ReentrantLock();

    //可写标志
    private final Condition canWrite = lock.newCondition();

    //可读标志
    private final Condition canRead = lock.newCondition();

    //对象数组
    Object[] items = new Object[100];

    private int readIndex,writeIndex,count;

    public void write(Object obj) {
        lock.lock();
        try {
            while(count == items.length) {
                canWrite.await();
            }
            items[writeIndex] = obj;
            if (++writeIndex == items.length) {
                writeIndex = 0;
            }
            ++count;
            canRead.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }


    public Object read() {
        Object result = null;
        lock.lock();
        try {
            while (count == 0) {
                canRead.await();
            }
            result = items[readIndex];
            if (++readIndex == items.length) {
                readIndex = 0;
            }
            --count;
            canWrite.signal();
            return result;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return result;
    }
    }

`java.util.concurrent.ArrayBlockingQueue`类提供了这种功能，因此可以直接用该类替换数组，实现对阻塞线程的控制

## ThreadLocal源码分析 ##
`ThreadLocal`不是用来解决共享对象的多线程访问问题的，一般情况下，通过`ThreadLocal.set()`到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到。
另外，`ThreadLocal`使得各线程保持各自一个独立的对象，并不是通过`ThreadLocal.set()`来实现的，而是通过每个线程中的`new`对象来创建对象，再通过`ThreadLocal.set()`方法将该对象的引用保存到该线程的`threadLocals`中(`map`类型)，键是`ThreadLocal`实例，在调用`get()`方法时，会取之前放进去的对象，如果本来该对象就是多线程共享的同一个对象，那么多线程的`ThreadLocal.get()`取得的还是这个共享对象本身，还是会存在并发访问的问题。
看一下`ThreadLocal`的具体应用：

    private static final ThreadLocal threadSession = new ThreadLocal();  
      
    public static Session getSession() throws InfrastructureException {  
        Session s = (Session) threadSession.get();  
        try {  
            if (s == null) {  
                s = getSessionFactory().openSession();  
                threadSession.set(s);  
            }  
        } catch (HibernateException ex) {  
            throw new InfrastructureException(ex);  
        }  
        return s;  
    } 
首先通过`threadSession.get()`判断当前线程中有没有保存`session`实例，如果没有那么通过`getSessionFactory().openSession()`创建一个新的`session`，并调用`threadSession.set(session)`将该`session`保存到当前线程的`threadLocals`变量中，这样可以保证每个线程都会有个自己独立的`session`对象，因此`ThreadLocal`的应用场合最适合按线程多实例(每个线程对应一个实例)的对象的访问，并且这个对象很多地方都要用到。

总之，`ThreadLocal`不是用来解决对象共享访问问题的，而主要是提供了保持对象的方法和避免参数传递的方便的对象访问方式，归纳了两点：
1、每个线程中都有一个自己的`ThreadLocal.ThreadLocalMap`对象`threadLocals`,初始值是`null`，可以将线程自己的对象保持在其中，各管各的，线程可以正确的访问自己的对象
2、将一个公用的`ThreadLocal`静态实例作为`key`，将不同对象的引用作为值保存到不同线程的`threadLocals`中，然后线程执行过程中通过这个静态`ThreadLocal`实例的`get()`方法获取自己保存的那个对象，避免了将这个对象作为参数传递的麻烦

`ThreadLocal`源码解析：
`get()`方法：

    public T get() {
        Thread t = Thread.currentThread();
        //获取当前线程的threadLocals变量(ThreadLocalMap<ThreadLocal<?>,Object>类型，初始值为null)
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            //如果map不为空，则取key为this对应的值
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        //没取到值则返回初始值
        return setInitialValue();
    }

`setInitialValue()`方法：

    private T setInitialValue() {
        //初始化值方法，默认返回null，可以被子类覆盖
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            //map非空，设置value
            map.set(this, value);
        else
            //new一个ThreadLocalMap
            createMap(t, value);
        return value;
    }

`set()`方法：

    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }

官方文档给出的一个实例：
    
    //给每个线程分配一个单独的线程ID，该线程ID在线程第一次调用ThreadId.get()方法时就会分配，以后每次调用都不会改变
    //只要线程仍存活、ThreadLocal实例可访问，那么该线程就拥有一个线程局部变量的副本的引用，当线程死亡后，如果没有其他引用指向该副本，那么该副本就会被GC回收
    public class ThreadId {
        
        private static final AtomicInteger nextId = new AtomicInteger(0);
        
        private static final ThreadLocal<Integer> nextId = new ThreadLocal<Integer>() {
            protected Integer initialValue() {
                return nextId.getAndIncrement();
            }
        };
        
        public static int get() {
            return threadId.get();
        }
    }

## 经典的Consumer/Producer ##






