# 多线程

标签（空格分隔）： JAVA

---

线程
--

## 1、五种基本状态 ##
调用方法`threadObj.getState()`可以查看线程状态，线程状态是个枚举类型，分为：
1、`NEW`：新建线程，还未开始
2、`RUNNABLE`:可执行线程，表示正在`JVM`中运行，但是可能需要等待获取处理器资源
3、`BLOCKED`：处于等待监视器锁的阻塞状态(同步阻塞)
4、`WAITING`：等待其他线程执行，`wait()`和`join()`
5、`TIMED_WAITING`:等待指定的时间，如`wait(long)`、`join(long)`等
6、`TERMINATED`:完成执行
 - **新建状态**：当线程对象创建后，即进入了新建状态
 - **就绪状态**：当调用线程的`start()`方法，线程即进入就绪状态，此时并不标明线程会立马执行，而是等待`CPU`的调度，如果获得了时间片即可执行线程
 - **运行状态**：就绪状态是进入运行状态的唯一入口，此时线程处于运行状态中，也就是开始执行`run()`方法
 - **阻塞状态**：处于运行状态中的线程由于某种原因，暂时放弃对`CPU`的使用权，停止执行进入阻塞状态，根据阻塞原因，阻塞状态可以分为三种：
    1、等待阻塞：运行中的线程执行`wait()`方法，使本线程进入到等待阻塞状态
    2、同步状态：线程在获取`synchronized`同步锁失败（因为锁被其他线程占用），该线程会进入同步阻塞状态
    3、其他阻塞：通过调用线程的`sleep()`或者`join()`方法或者发出了`I/O`请求(`IO`操作一般是阻塞的，即如果线程进行了`IO`操作，那么该线程必须等待`IO`操作完成才能干别的事情)时，线程会进入阻塞状态，当`sleep()`状态超时、`join()`等待线程终止或者超时、或者`I/O`处理完毕时，线程重新进入就绪状态
    4、调用`LockSupport.park()`方法时，会使当前线程不参与线程调度，除非通过以下方式得到执行权：
    （1）其他线程调用与此线程相关的`unpark()`方法
    （2）其他线程调用了阻塞线程的`interrupt()`方法
    （3）调用虚拟返回
 - **死亡状态**：线程执行完了或者抛出异常退出了`run()`方法，该线程结束生命周期

线程状态切换：

![线程状态切换][1]

## 2、线程的阻塞状态和控制方法 ##

 - `join()`：线程对象方法，`thread.join()`，如在`A`线程中调用`B.join()`则会阻塞`A`线程(查看`join(0)`方法的源码，该方法使用了`synchronized`加锁)，调用`B`线程直到线程死亡，才会重新调用`A`线程
 - `sleep()`：让当前执行的线程暂停指定时间，并进入阻塞状态，在暂停时间内，该线程不是处于就绪状态，因此不会得到执行的机会，即使系统中没有其他的可执行的线程，该线程也不会执行，因此`sleep()`方法常被用来暂停线程执行，注意`sleep`过程中线程不会释放持有的对象锁
 - `setPriority()`：设置线程的优先级，优先级高的仅表示其具有更多的执行机会，并不一定在优先级低的线程前执行，三个优先级：`MIN_PRIORITY``NORM_PRIORITY``MAX_PRIORITY`
 - `yield()`：文档解释，提示调度器当前线程愿意放弃处理器的占用，而调度器可以自由决定是否忽略此提示

## 3、线程同步synchronized关键字的用法 ##
`synchronized`是`java`中的关键字，是一种同步锁，它修饰的对象有以下几种：

 - 修饰一个代码块，被修饰的代码块称为同步代码块，同步的作用域是对象，通常有如下几种写法：

    synchronized(this){}    //这和修饰方法是等价的
    synchronized(obj){} //A线程访问该代码块时，会拿到obj对象的锁，其他线程就无法访问该代码块
    synchronized(new byte[0]){}

 - 修饰一个方法，被修饰的方法称为同步方法，其作用域是整个方法，作用的对象是调用这个方法的对象
    public synchronized void run() {}

 - 修饰一个静态方法，其作用域是整个静态方法，作用对象是这个类的所有对象
    public synchronized static void method() {}

 - 修饰一个类，其作用范围是括号里的代码，作用对象是这个类的所有对象
    public void method() {
        synchronized(this.getClass()){}
    }

## Thread源码分析 ##

1、`join()`方法：

`join`方法是一个对象方法，通常在某线程`thread1`中通过`thread2.join()`方法强行让`thread1`等待直到`thread2`执行完，内部是通过`wait()`方法来实现的，因此在分析`join()`方法的实现原理前必须先了解`wait()`方法，`wait()`方法是`Object`的对象方法，它会使当前线程释放掉对象锁进入等待阻塞状态，直到调用`notify()`或者`notifyAll()`方法唤醒等待该对象锁的线程，并且重新通过竞争机制获取对象锁后才能返回，并恢复线程执行。`join()`方法源码如下：

    //签名使用synchronized关键字，表明当前执行线程(主线程)已经获取该线程对象thread(thread.join())的对象锁
    public final synchronized void join(long millis) 
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) { //如果thread还未销毁，则主线程继续阻塞
                wait(0);    //主线程释放thread对象锁，并进入等待阻塞状态，直到thread线程执行完，主线程重新拿到thread对象锁
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }

2、`sleep()`方法：

`sleep()`方法源码如下：
    
    //文档解释：使当前线程休眠一段时间(停止执行)，但此时该线程并没有释放掉对象锁
     public static native void sleep(long millis) throws InterruptedException;

## 线程中断机制 ##
线程的`Thread.interrupt()`方法会设置该线程的中断标志位，设置完标志位之后的线程是死亡、等待新的任务或是运行至下一步就取决于程序本身。
调用线程的`Thread.interrupt()`方法如果发生以下三种情况，会抛出异常：
1、如果线程在调用`wait()/wait(timeout)/join()/join(timeout)/sleep()/sleep(timeout)`等方法后处于阻塞状态，并且在此阻塞状态有其他线程调用该阻塞线程的`interrupt()`方法会直接抛出`InterruptedException`，线程中断标志位被清除，阻塞线程会被唤醒。
2、如果线程在`InterruptibleChannel`上执行了`IO`操作而阻塞，那么中断之后`channel`将被关闭，线程中断标志位被设置，并且会抛出`ClosedByInterruptException`异常
3、如果线程在`Selector`中被阻塞(`Selector.select()`)，线程中断标志会被设置，并且阻塞方法会立即返回，这和`Selector.wakeup()`方法类似

如果上述三种情况均为发生，那么线程的中断标志位将被设置。

其他线程中断相关方法：

1、`isInterrupted()`：实例方法，判断线程是否被中断，不会影响线程的中断标志。

2、`interrupted()`:静态方法，判断线程是否被中断，并清除其中断状态，如果连续两次调用`interrupted()`方法，第二次方法返回`false`，除非在第一次调用之后，第二次调用之前其他线程再次调用了`interrupt()`方法中断线程。

假如线程在阻塞状态下被中断，会立即抛出`InterruptedException`异常，并唤醒阻塞线程，同时清除中断标志位，但是`synchronized`在获取锁的过程中是不能被中断的，意思是如果产生了死锁，则不可能被中断。

没有任何语言方面的需求一个被中断的线程应该终止，中断一个线程只是给线程发起了一个中断请求，设置中断标志位，而被中断线程具体如果处理中断可以自行决定：

    public void run() {
        try {
            while(!Thread.currentThread().isInterrupted() && other conditions) {
                do some work
            }
        } catch(InterruptedException e) {
            //线程可能在阻塞过程中被中断
        } finally {
            //线程结束前做一些清理工作
        }
    }

使用`thread.interrupt()`中断阻塞状态线程：
    当线程处于阻塞状态时(如调用`sleep`、`wait`、`join`等方法)，调用阻塞线程的`interrupt`方法会使阻塞线程结束阻塞状态，并抛出`InterruptedException`异常，
其中断标志也会被清除，相当于调用线程给阻塞线程发送了一个中断请求，阻塞线程如何处理这个中断请求可以自定义：

    class Example3 extends Thread {
         public static void main(String args[]) throws Exception {
             Example3 thread = new Example3();
             System.out.println("Starting thread...");
             thread.start();
             Thread.sleep(3000);
             System.out.println("Asking thread to stop...");
             thread.interrupt();// 等中断信号量设置后再调用
             Thread.sleep(3000);
             System.out.println("Stopping application...");
         }

 
     public void run() {
         while (!Thread.currentThread().isInterrupted()) {
             System.out.println("Thread running...");
             try {
                 /*
                  * 如果线程阻塞，将会不断的轮询中断标志位，所 以thread.interrupt()
                  * 会使阻塞线程从阻塞的地方抛出异常，让阻塞线程从阻塞状态逃离出来，并
                  * 进行异常块进行 相应的处理
                  */
                 Thread.sleep(1000);// 线程阻塞，如果线程收到中断操作信号将抛出InterrptedException异常
             } catch (InterruptedException e) {
                 System.out.println("Thread interrupted...");
                 /*
                  * 如果线程在调用 Object.wait()方法，或者该类的 join() 、sleep()方法
                  * 过程中受阻，则其中断状态将被清除
                  */
                 System.out.println(this.isInterrupted());// false
 
                 //中断线程，退出上面的while循环
                 Thread.currentThread().interrupt();
             }
         }
         System.out.println("Thread exiting under request...");
     }
     }

## 死锁Deadlock ##
死锁的定义：两个线程互相持有对方需要的锁，比如线程`A`持有锁`M`想要锁`N`，而线程`B`持有锁`N`想要锁`M`，这样就可能出现死锁情况
出现死锁后，可以先`jps`查看进程`ID`，再使用`jstack`查看死锁堆栈信息，可用`taskkill pid`杀死死锁进程
## 偏向锁和自旋锁##
**偏向锁**

当锁被争用时，`JVM`可以选择如何分配锁，锁可以被公平地授予，每个线程以轮转调度方式获取锁，还可以偏向于分配给对锁访问最频繁的线程，偏向锁背后的理论是，如果一个线程最近用到了某个锁，那么线程下一次执行由同一把锁保护的代码所需的数据可能仍然保存在处理器的缓存中，如果给这个线程优先获得这把锁的权利，缓存命中率就会增加，如果实现了这点性能会有所改进，但是因为偏向锁也需要一些簿记信息，故有时性能可能会更糟，特别是，使用了某个线程池的应用(包括大部分应用服务器)，在偏向锁生效的情况下，性能会更糟，在那种编程模型下，不同的线程有同等机会访问争用的锁。对于这些类应用，使用`-XX:-UseBiasedLocking`选项禁用偏向锁，会稍稍改进性能。偏向锁默认是开启的

**自旋锁**

在处理同步锁的竞争问题时，`JVM`有两种选择，对于想要获得锁而陷入阻塞的线程，可以让它进入忙循环，执行一些指令，然后再次检查这个锁。也可以把这个线程放入一个队列，在锁可用时通知它(`Object.wait`方法将线程放入条件队列，等待其他线程唤醒)。

如果多个线程竞争锁的被持有时间较短，那么忙循环(所谓的线程自旋)就比另一个方案快得多，如果被持有时间长，则让第二个线程等待通知会更好，而且这样第三个线程也有机会使用`CPU`

## volatile关键字 ##
几个概念：内存、工作内存(高速缓存)、原子性、可见性、有序性

**可见性**：普通共享变量被修改之后，什么时候被写入内存是不确定的，当其他线程在修改和写入内存之间去读取时，此时内存中还是原来的旧值，这就可能导致修改的不可见性，`volatile`关键字可以保证**值读取**可见性(整个值读取过程没有被打断，如果被打断就是`volatile`无法保证原子性的原因)，修改变量后立即将工作内存中的值刷入主存中，并使其他线程工作内存对应的缓存行无效，直接从主存中拿值。

**原子性**：在`Java`中，对基本类型的变量的赋值是原子性的，即这些操作是不可被中断的，要么执行，要么不执行
`volatile`**保证了变量的可见性**，即它会保证修改的值立即更新到主存中，当其他线程需要时直接去内存中读取新值，**但无法保证所有操作的原子性**
`volatile`为什么会保证可见性：这里就要提到内存屏障(`memory barrier`)，内存屏障是一个`CPU`指令，它可以**a)**确保一些特定操作执行的顺序**b)**影响一些数据的可见性，可以强制更新内存。所以对于`volatile`字段，`jvm`会在写操作后面插入一个写屏障指令，在读操作前插入一个读屏障指令，这样可以保证更新的值刷新至内存，举个例子：

    例如一个volatile的Integer自增操作其实要分为三步：1)读取变量到缓存中2)增加变量的值3)把缓存中的值写入内存让其他线程可见(最后一步是内存屏障)
    Load->Increment->Store->StoreLoad Barrier
内存屏障提供三个功能：
1)确保指令重排序时不会把后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面，即保证之前的操作全部完成
2)会强制将缓存中的修改刷入内存
3)如果是写操作，会导致其他CPU中对应的缓存行无效

`synchronized`和`Lock`也可以保证可见性，它们保证同一时刻只有一个线程能够拿到锁并执行同步代码，并且在释放锁之前将变量的修改刷新到主存中
原子性操作：简单的读取、赋值才是原子性操作
`volatile`无法保证原子性的原因：同样，以`volatile`修饰的变量自增为例`i++`，设`i`的初始值为10，假如线程1对变量进行自增操作，执行第一步`Load`从内存中读取`i`，然后线程1被阻塞了，接着线程2对变量进行自增操作，线程2也去内存中读取变量的值，此时`i`的值仍为10，然后执行自增操作，写入内存，然后线程1恢复运行，由于此时线程1已经读取了`i`的值10(这里为什么线程1缓存行无效，但是线程1读取操作已经进行，直接从缓存中拿值)，自增并写入内存，最后2个线程分别执行自增操作后，内存中`i`的值为11，这显然出现了线程不安全，原因在于自增操作不是原子性操作，而`volatile`无法保证操作的原子性

对于普通变量：读操作会优先读取工作内存的数据，如果工作内存中不存在，则从主存中拷贝一份数据到工作内存中，写操作会将值写入工作内存，但什么时候刷入主存是未知的
对于`volatile`变量：读操作时`JVM`会把工作内存中的缓存行设为无效，要求线程从主内存中读取数据，写操作时`JVM`会把工作内存中对应的数据刷新到主存中，这种情况下其它线程就可以读取变量的最新值
**java中的原子操作**：

 - 基本类型赋值，除了`long`和`double`(8字节，64位，对于64位操作系统是原子操作，而对于32位操作系统则不是，会先赋值前32位，再赋值后32位，这样会导致线程不安全)
 - 引用赋值
 - `java.concurrent.Atomic*`类的所有操作
 - `volatile`关键字的`long `和`double`赋值(`volatile`本身并不能保证操作的原子性，但`jvm`能保证`long `和`double`的读写操作是原子性的)

**乐观锁和悲观锁**

`java`在`jdk1.5`之前都是靠`synchronized`关键字来保证同步的，如果出现多个线程同时访问锁，那除了拿到锁的线程之外所有的线程都将被挂起，当锁线程执行完毕后，其他线程才能恢复执行，在挂起和恢复执行的过程中存在着很大的开销，锁还存在一些缺点，当一个线程正在等待锁时，它不能做任何事，如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去，如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转(`Priority Inversion`)

独占锁是一种悲观锁，`synchronized`就是一种**独占锁**，他只有确保其他线程不会造成干扰的情况下执行，会导致其他所有需要锁的线程挂起，等待有锁的线程释放锁，而另一个更加有效的锁就是乐观锁，所谓**乐观锁**就是线程在使用数据时，乐观地认为不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入，如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作(例如报错或者自动重试)

**悲观锁适合写操作多**的场景，先加锁以保证写操作的正确性

**乐观锁适合读操作**的场景，不加锁的特点使其读操作性能大幅提升

**CAS无锁算法**
要实现无锁(`lock-free`)的非阻塞算法有很多实现方法，其中`CAS`(比较和交换，`compare and swap`)是一种有名的无锁算法，`CAS`是一个`CPU`指令，在大多数处理器架构中，都采用了`CAS`指令，它的语义是:

    我认为V的值是A，如果是那么将V值更新为B，否则不修改并告诉V的实际值是多少

`CAS`是一种乐观锁技术，当多个线程尝试使用`CAS`同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程不会被挂起，而是被告知失败并可以再次尝试，`CAS`有三个操作数，内存值`V`，旧的预期值`A`以及要修改的新值`B`，当且仅当预期值`A`和内存值`V`相同时，才会将内存值更新为`B`，否则什么都不做，其`C`算法如下：

    int compare_and_swap (int* reg, int oldval, int newval) 
    {
      ATOMIC();
      int old_reg_val = *reg;
      if (old_reg_val == oldval) 
         *reg = newval;
      END_ATOMIC();
      return old_reg_val;
    }

`CAS`存在常见的`ABA`问题，通常可以通过增加版本号来解决，例如`AtomicStampedReference`
另外，循环时间长，开销比较大，如果并发量相当高，`CAS`操作长时间不成功，会导致其一直自旋，带来`CPU`消耗

## 双重检查锁定(Double Checked Locking) ##


    public class DoubleCheckedSingleton {

        //必须使用volatile关键字，禁止指令重排序
        private volatile static DoubleCheckedSingleton instance = null;
    
        public DoubleCheckedSingleton() {
        }
    
        public static DoubleCheckedSingleton getInstance() {
            if (instance == null) { //多线程情况下此处可能会拿到instance还没有实例化完全的实例
                synchronized (DoubleCheckedSingleton.class) {
                    if (instance == null) {
                        instance = new DoubleCheckedSingleton();    //new操作实际上分为三步，分配内存、实例化对象，将instance指向该内存，这三条操作可能会重排序
                    }
                }
            }
            return instance;
        }
    }
    
    
## Executor框架 ##
在`java.util.concurrent`包下，引入了`Executor`框架，其内部使用了线程池机制，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此在`Java 5`之后，通过`Executor`来启动线程比使用`Thread`的`start()`方法来启动线程更好，除了易于管理、效率更高(用线程池实现，节约开销)外，还有关键的一点，避免`this`逃逸问题。
`Executor`框架包括：线程池、`Executor`、`Executors`、`ExecutorService`、`CompletionService`、`Future`、`Callable`等

 - `Executor`接口：用于提交`Runnable`任务，提供了诸多方法将任务提交和任务执行解耦，包括线程使用、调用等细节。

 一段简单的代码：
 

    Executor executor = anExecutor;
    executor.execute(new RunnableTask1());
    executor.execute(new RunnableTask2());
    
然而，`Executor`并不是只能异步执行任务，同样可以在调用线程中立即执行提交的任务：

    class DirectExecutor implements Executor {
        public void execute(Runnable r) {
            r.run();
        }
    }
同样，该任务也可以在其他线程中执行：

    class ThreadPerTaskExecutor implements Executor {
        public void execute(Runnable r) {
            new Thread(r)
        }
    } 

`Executor`提供的方法：

    public interface Executor {
        void execute(Runnable command);
    }

 - `ExecutorService`接口：继承自`Executor`接口，提供了管理`Executor`生命周期的方法，并且通过`Future`接口跟踪一个或者多个异步任务执行的过程。
`ExecutorService`能够被终止(`shutdown`)，终止后，无法继续接受新的任务，有两个`shutdown`方法：

1、`shutdown()`：停止接收新的任务，这个方法不会等待之前提交的任务完成执行，调用`awaitTermination()`方法来完成所有提交的任务执行。

2、`shutdownNow()`：不会执行还未执行的任务，并且强制停止当前正在执行的任务。
`Executor`一旦停止，就没有任务正在执行，没有任务等待执行，没有任务能够被提交，没有使用的`ExecutorService`应该关闭释放资源。
`submit()`方法重载了父类的方法，返回`Future`实例，可以用来取消执行或者等待执行完成，`invokeAny`方法当任何一个任务执行成功后返回`Future`实例，`invokeAll`方法执行批量任务，当所有任务都执行完毕后返回`Future`实例`List`

其他方法：
1、`awaitTermination(timeout, unit)`:在`shutdown`请求之后等待所有的任务执行完毕直到超时限制或者当前线程被中断，终止返回`true`，如下方法展示了如何关闭：

        void shutdownAndAwaitTermination(ExecutorService pool) {
            pool.shutdown(); // Disable new tasks from being submitted
            try {
                // Wait a while for existing tasks to terminate
                if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {
                    pool.shutdownNow(); // Cancel currently executing tasks
                    // Wait a while for tasks to respond to being cancelled
                    if (!pool.awaitTermination(60, TimeUnit.SECONDS))
                        System.err.println("Pool did not terminate");
                }
            } catch (InterruptedException ie) {
                // (Re-)Cancel if current thread also interrupted
                pool.shutdownNow();
                // Preserve interrupt status
                Thread.currentThread().interrupt();
            }
        }

2、`isShutdown()`：是否关闭

3、`isTerminated()`:在接收到`shutdown`或者`shutdownNow`请求后是否执行完所有的任务

 - `Executors`类：提供了大量的工厂和工具类方法用于创建线程池，返回的线程池都实现了`ExecutorService`接口

下面简要介绍下`Executors`类中创建线程池的静态方法，首先介绍下`ThreadPoolExecutor`的构造方法：

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
    
参数定义：

 - `corePoolSize`:核心线程数量，指的是线程池中最少线程的数量，即使它们是空闲`idle`的，也不会被移出线程池
 - `maximumPoolSize`:最大线程数量
 - `keepAliveTime`:当**线程池中线程数量大于核心线程数量时**，这个参数表示多余的空闲线程等待新任务的最大时间，否则将被终止，如果线程池中线程数量小于核心线程数量，这个参数没用
 - `unit`：`keepAliveTime`的时间单位
 - `workQueue`:任务执行前保存他们的队列，这个队列只会保存`execute`方法提交的`Runnable`任务
 - `threadFactory`:创建线程的线程工厂，默认是`Executors.defaultThreadFactory()`返回的`DefaultThreadFactory`
 - `handler`:当达到线程池中线程数量达到`maximumPoolSize`并且队列已满时的任务处理器，有四种实现方式，默认是`AbortPolicy`，直接抛出`RejectedExecutionException`异常

接着看一下`Executors`提供的静态方法：

 - 创建固定数量线程的线程池：

        public static ExecutorService newFixedThreadPool(int nThreads) {
            return new ThreadPoolExecutor(nThreads, nThreads,
                                          0L, TimeUnit.MILLISECONDS,
                                          new LinkedBlockingQueue<Runnable>());
        }

设置了`corePoolSize=maximumPoolSize=nThreads`，`keepAliveTime=0`，任务队列选用的是**无边界**的`LinkedBlockingQueue`，可以看出该线程池具有以下特性：线程池中最多会存在`nThreads`个线程，每来一个新任务，如果线程池中线程数量小于`nThreads`，那么会新建线程执行该任务，否则任务进入队列，等待空闲线程

 - 创建缓存性线程池：

        public static ExecutorService newCachedThreadPool() {
            return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
                                      }

参数分别为`0,Integer.MAX_VALUE,60`,核心线程池数量`corePoolSize=0`，最大线程数量`maximumPoolSize=Integer.MAX_VALUE`，线程存活`keepAliveTime=60s`，任务队列选用的是`SynchronousQueue`，该队列会将任务直接交给线程执行，会直接`reuse`池子中空闲的线程，如果所有的线程都是忙碌状态，会新建一个新的线程放入池中，缓存型线程池通常用于执行生存期很短的异步型任务，空闲线程的`idle`时间为60秒，在时间之内的线程可以被`reuse`，否则将被移出线程池

 - 创建单例线程：

        public static ExecutorService newSingleThreadExecutor() {
            return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
                                    }
参数分别为：`1,1,0`,底层池和固定池、缓存池一样，单例池中只有一个线程，任务队列也是**接近无**限的队列

 - 创建调度型线程池：
 

        public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
            return new ScheduledThreadPoolExecutor(corePoolSize);
        }
这个池子里的线程可以按`schedule`依次`delay`执行，或周期执行

阿里巴巴`Java`规范有一点建议：

    线程池最好不要使用Executors来创建，而是通过ThreadPoolExecutor来构造，这样的处理方式可以更加明确线程池的运行规则，规避资源耗尽的风险。Executors返回的线程池对象弊端如下：
    1）FixedThreadPool和SingleThreadPool：允许任务队列长度为Integer.MAX_VALUE，可能会堆积大量请求任务，导致OOM
    2）CacheThreadPool和ScheduledThreadPool：允许创建线程数量为Integer.MAX_VALUE，可能会创建大量线程，从而导致OOM

**Callable接口**

在`Java`中，任务分为两类，一类是`Runnable`，一类是`Callable`接口，两者都可以被`ExecutorService`执行，但是`Callable`有返回值而`Runnable`没有，可以查看`ExecutorService`接口中的方法对比：

 - `<T> Future<T> submit(Callable<T> task)`:提交`Callable`任务，并返回`Future`对象，通过`Future`对象的`get()`方法获取计算结果

**Future接口** 

`Future`接口表示异步计算的结果，该接口提供了检查计算是否完成、阻塞获取结果的方法，`ExecutorService`中的`submit`方法就可以提交异步任务，返回`Future`实例。
方法列表：

    public interface Future<V> {
    boolean cancel(boolean var1);   //取消任务执行

    boolean isCancelled();  //在任务完成之前是否被取消是否被取消

    boolean isDone();   //任务是否完成，终止、异常或者取消都会返回true

    V get() throws InterruptedException, ExecutionException; //等待任务执行完毕，返回结果

    V get(long var1, TimeUnit var3) throws InterruptedException, ExecutionException, TimeoutException;   //等待超时时间获取任务执行结果，如果超时任务还没执行完成，会抛出TimeoutException
    }

## 线程池ThreadPoolExecutor ##


实现了`ExecutorService`接口，使用线程池中的线程来执行提交的任务，通常可以通过`Executors`提供的工厂方法来配置线程池。
线程池在执行大量的异步任务时效率很高，并且提供了一系列管理线程资源的手段，同时还实现了一些基本统计，例如已完成任务的数量。
线程池会根据设置的`corePoolSize`和`maximumPoolSize`来调整池中线程的数量，当一个新的任务提交进来时，如果少于`corePoolSize`数量的线程在运行，那么会创建一个新的线程处理任务，即使有工作线程闲置，如果线程数量大于`corePoolSize`小于`maximumPoolSize`，只有当队列满时才会创建新的线程，如果设置`corePoolSize=maximumPoolSize`，相当于创建了一个固定大小的线程池，一般的这两个参数在构造期间就指定，也可以在运行期间通过方法动态改变。
默认情况下，核心线程会初始化创建，当任务达到时才会`start`，这可以通过调用`prestartCoreThread()`或者`prestartAllCoreThreads`方法动态调整。
线程池中的线程默认是通过`ThreadFactory`创建，通常使用`Executors.defaultThreadFactory`。
如果线程池中线程数量大于核心线程数量，超过的线程如果空闲时间超过了`keepAliveTime`，那么该线程会被终止，这可以有效的减少资源消耗。

**任务入队操作**：

1、如果线程数量小于核心线程数量，那么线程池会优先创建新的线程，而不会将任务入队

2、如果线程数量大于核心线程数量，那么会优先将任务入队而不是创建新的线程

3、如果任务无法入队(队列满了)，那么会创建新的线程，除非线程数量超过了最大线程数量限制，否则该任务将被线程池拒绝

**队列实现有多种策略**：

1、`Direct handoffs`，例如`SynchronousQueue`同步队列，当任务到达时不会入队而是直接开启线程执行任务，这通常适用于无边界线程池。
2、无界队列，例如`LinkedBlockingQueue`，当所有的核心线程都在忙着执行任务时，新来的任务会被入队等待，此时线程池中的线程数量永远无法大于核心线程数量
3、有界队列，例如`ArrayBlockingQueue`，当使用有限的最大线程池数量时，能够阻止资源的消耗，但是可能更难去调节和控制，队大小和最大线程数量会互相限制，使用大的队列和小的线程池可以减少`CPU`消耗、系统资源和上线文切换，但是可能导致较低的吞吐量。

**拒绝任务**：

    新任务提交时，如果`Executor`关闭，那么该任务会被拒绝，或者当线程池具备有限的最大线程数量和工作队列容量，当工作队列和线程池中线程数量饱和时，新来的任务也可能被拒绝，这个时候会调用`RejectedExecutionHandler`的`rejectedExecution`方法，线程池提供了4种拒绝策略：
    1、默认`ThreadPoolExecutor.AbortPolicy`，会抛出`RejectedExecutionException`运行时异常。
    2、`ThreadPoolExecutor.CallerRunsPolicy`，由调用线程执行任务，提供了一种简单的反馈控制机制，可以减慢新任务提交的速率。
    3、`ThreadPoolExecutor.DiscardPolicy`，直接将任务丢弃。
    4、`ThreadPoolExecutor.DiscardOldestPolicy`，会将队列开头的任务出列并丢弃，然后重新`execute`当前任务，如果再次失败则再次执行此策略重复。

**线程池源码分析**

线程池的控制状态变量由`ctl`表示(`pool control state`)，这是一个`AtomicInteger`类型的变量，它包装了两个概念域：工作线程数量(`workerCount`)和线程池的运行状态(`runState`)，为了将这两个变量包装再一个`int`里面，高三位用来表示线程池状态，后面的29位用来表示线程池工作线程数量，因此这也限制了工作线程数量不能超过`2^29-1`，大约500万个，而线程池的状态有多种如下所示：

 - `RUNNING`:接受新的任务并处理工作队列中的任务
 - `SHUTDOWN`:不再接受新任务，但仍会处理工作队列中的任务
 - `STOP`:不接受新任务，不处理工作队列中的任务，并打断处理中任务
 - `TIDYING`:所有任务已经终止，工作线程数量为0，转变到`TIDYING`状态的线程会执行`terminated()`钩子方法
 - `TERMINATED`:`terminated()`方法执行完成

线程池状态转变：

`RUNNING -> SHUTDOWN`:调用`shutdown()`方法，可能隐式地再`finalize()`方法中调用

`RUNNING or SHUTDOWN -> TIDYING`:调用`shutdownNow()`方法

`SHUTDOWN -> TIDYING`:当队列和线程池都是空

`STOP -> TIDYING`:当线程池为空时

`TIDYING -> TERMINATED`:当`terminated()`钩子方法完成时

调用`awaitTermination()`而阻塞的线程再线程池状态变为`TERMINATED`时会结束等待状态。

看一下`ThreadPoolExecutor`中关于这些线程池状态或者`ctl`的定义：

![线程池状态变量定义][2]


    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));   
    private static final int COUNT_BITS = Integer.SIZE - 3;   //表述线程池数量的位数，29位
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;    //工作线程最大数量限制，2^29-1个

    // runState is stored in the high-order bits
    //线程池运行状态存储在高三位中，算法很简单，左移29位
    private static final int RUNNING    = -1 << COUNT_BITS; //运行状态
    private static final int SHUTDOWN   =  0 << COUNT_BITS; //SHUTDOWN
    private static final int STOP       =  1 << COUNT_BITS; //STOP
    private static final int TIDYING    =  2 << COUNT_BITS; //TIDYING
    private static final int TERMINATED =  3 << COUNT_BITS; //TERMINATED

    // Packing and unpacking ctl
    //ctl封装了runState(高三位)和workerCount(后29位)
    private static int runStateOf(int c)     { return c & ~CAPACITY; } //获取ctl对应的runState，即获取到最高三位的值，后29位置0
    private static int workerCountOf(int c)  { return c & CAPACITY; }  //获取ctl对应的workerCount，获取后29位的值，最高3位置0
    private static int ctlOf(int rs, int wc) { return rs | wc; }   //获取ctl值，将runState和workerCount或

线程池核心方法`execute()`方法，该方法分三步处理，首先如果低于核心线程池数量的线程在运行，开启一个新的线程来执行`command`，`addWorker`方法会自动检查`runState`和`workerCount`，避免了在不应该增加线程时增加了线程，此时该方法会直接返回`false`，其次如果任务能够被成功入队，那么我们仍然需要二次检查是否应该增加新的线程(可能在上次检查之后有线程死亡)或者进入这个方法之后线程池关闭了，因此我们再次检查了运行状态，如果线程池停止有必要进行回滚入队操作，或者如果不存在任何线程的情况下重新开启一个线程，最后如果我们无法将任务入队，我么会尝试增加一个新的线程，如果操作失败，可以知道此时线程池已经关闭或者饱和，那么执行拒绝策略拒绝任务：

    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        //如果线程池中工作线程数量小于核心线程池数量，调用addWorker方法开启新的线程执行任务
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }

`addWorker`方法：

    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            //如果线程池SHUTDOWN，并且满足一下条件之一，不会创建新的worker，特别注意一点如果线程池状态为SHUTDOWN不会接收新的任务
            //1.线程池状态大于SHUTDOWN，也就是STOP/TIDYING/TERMINATED
            //2.firstTask != null
            //3.workerQueue.isEmpty()
            //如果线程池处于SHUTDOWN，firstTas为null且workQueue非空是允许创建线程的
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                int wc = workerCountOf(c);
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                //如果增加线程计数器成功，那么退出retry
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                //再次读取ctl，判断线程池状态runState是否发生了改变，如果改变了则回到外层的for循环重新获取线程池状态runState
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
                //如果由于线程池工作线程数量workerCount发生改变导致CAS失败，继续里层的for循环，重新CAS
            }
        }
        
        //先验条件已满足，通过CAS增加了线程池中工作线程的数量，接下来就要开启新的线程
        //定义了两个变量，workerStarted表示工作线程是否开始，workerAdded表示工作线程是否添加到线程池中
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            //构造Worker对象，将firstTask作为其第一个任务
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                //加锁，因为涉及到workers集合的操作，该集合是HashSet类型，非线程安全
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    //重新获取线程池状态，因为可能在获取锁的过程中线程池关闭，通过ThreadFactory创建线程失败也会直接退出
                    int rs = runStateOf(ctl.get());
                    
                    //如果runState小于SHUTDOWN，或者runState等于SHUTDOWN且firstTask等于null，那么准备增加Worker
                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                //开启线程
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            //如果线程开启失败，调用addWorkerFailed方法
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }

`addWorkerFailed`方法，该方法会回滚线程创建的操作，具体分为一下三步：

 - 从`workers`集合中移除`worker`
 - 减少`worker`的数量
 - 重新检查终止条件，防止该`worker`的存在阻止了终止流程的开始

源码如下：

    private void addWorkerFailed(Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        //加锁，涉及到workers集合的操作，该集合是HashSet类型，非线程安全
        mainLock.lock();
        try {
            if (w != null)
                workers.remove(w);
            decrementWorkerCount();
            tryTerminate();
        } finally {
            mainLock.unlock();
        }
    }

`tryTerminate`方法，如果处于`SHUTDOWN`状态且线程池和队列均为空或者处于`STOP`状态且线程池为空时转变到`TERMINATED`状态：

    final void tryTerminate() {
        for (;;) {
            int c = ctl.get();
            if (isRunning(c) ||
                runStateAtLeast(c, TIDYING) ||
                (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
                return;
            if (workerCountOf(c) != 0) { // Eligible to terminate
                interruptIdleWorkers(ONLY_ONE);
                return;
            }

            final ReentrantLock mainLock = this.mainLock;
            //加锁
            mainLock.lock();
            //将线程池状态转换为TIDYING，调用terminated()钩子方法，最后在将状态切换到TERMINATED，唤醒所有因为awaitTermination方法等待线程池TERMINATED的线程
            try {
                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                    try {
                        terminated();
                    } finally {
                        ctl.set(ctlOf(TERMINATED, 0));
                        termination.signalAll();
                    }
                    return;
                }
            } finally {
                mainLock.unlock();
            }
            // else retry on failed CAS
        }
    }

`awaitTermination`方法，等待线程池`TERMINATED`:

    public boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException {
        long nanos = unit.toNanos(timeout);
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (;;) {
                //如果线程池状态时TERMINATED，那么返回true
                if (runStateAtLeast(ctl.get(), TERMINATED))
                    return true;
                //如果nanos小于0，那么返回false
                if (nanos <= 0)
                    return false;
                //设置nanos，调用超时阻塞方法awaitNanos，如果超时未唤醒直接返回负值，此时nanos<0，下次循环时返回false，表明线程池状态未转变为TERMINATED
                nanos = termination.awaitNanos(nanos);
            }
        } finally {
            mainLock.unlock();
        }
    }

`Worker`实现了`Runnable`接口，看一下其构造方法：

    Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

其内部的线程对象`thread`封装了该`Worker`对象，线程开始时会调用`run`方法：

    public void run() {
            runWorker(this);
        }

再看`runWorker`方法：

    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        //如果firstTask不为null，那么首先执行该firstTask，接着从任务队列中获取任务执行，getTask是一个阻塞操作
        try {
            while (task != null || (task = getTask()) != null) {
                //执行任务之前要获取锁，这个锁是通过AQS实现的一把独占非重入锁
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    //调用beforeExecute
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    //执行任务
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        //调用afterExecute
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }

`getTask`方法，阻塞或者超时等待任务，如果出现了如下几种情况返回`null`：

 - 有超过`maximumPoolSize`的工作线程(通过`setMaximumPoolSize`方法设置)
 - 线程池停止(`STOP`)
 - 线程池关闭，且任务队列为空
 - 当前`worker`等待任务超时，超时`worker`需要被终止

源码如下：

    private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            //如果线程池SHUTDOWN且(状态大于STOP或者工作队列未空)，上述逻辑实际上等价于线程池状态为SHUTDOWN且任务队列为空或者线程池状态大于SHUTDOWN：if ((rs == SHUTDOWN && workQueue.isEmpty()) || rs > SHUTDOWN)
            //返回null
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // Are workers subject to culling?
            //allowCoreThreadTimeOut表示允许核心线程空闲超时回收
            //timed变量表示当前线程是否有超时限制，而不管线程池中工作线程数量是否超过了核心线程corePoolSize
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
            
            //逻辑很简单：条件一 & 条件二
            //条件一：wc大于最大线程数量或者等待任务超时
            //条件二：线程池中不止一个工作线程或者任务队列为空
            //当条件一 & 条件二成立时，那么CAS减少一个工作线程数量，返回null，如果CAS失败则继续下一轮循环
            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                //从任务队列workQueue中取任务
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                //判断r是否为null，如果为null，则表示超时
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }

**线程池的关闭机制**

线程池的关闭机制和三个方法相关：`shutdown`/`shutdownNow`以及`awaitTermination`

`shutdown`方法不会接受新的任务(通过调用`advanceRunState(SHUTDOWN)`方法将线程池状态设置为`SHUTDOWN`，在执行新任务调用`execute`方法时会拒绝任务，具体查看`addWorker`方法)，但是会继续执行任务队列中剩余的任务，可以使用`awaitTermination`来等待任务执行完成：

    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess();
            //将线程池状态设置为SHUTDOWN
            advanceRunState(SHUTDOWN);
            //(1)中断空闲线程，空闲线程正在等待从任务队列中获取任务
            interruptIdleWorkers();
            onShutdown(); // hook for ScheduledThreadPoolExecutor
        } finally {
            mainLock.unlock();
        }
        //(2)尝试终止线程池
        tryTerminate();
    }

(1)`interruptIdleWorkers`方法会给所有空闲线程发送中断信号：

    private void interruptIdleWorkers() {
        interruptIdleWorkers(false);
    }
    
    private void interruptIdleWorkers(boolean onlyOne) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (Worker w : workers) {
                Thread t = w.thread;
                //如果线程没有中断且w.tryLock尝试获取锁成功，Worker继承了AQS，它本身就提供了锁功能，它是一把独占非重入锁，看一下runWorker的代码，工作线程在成功从任务队列中获取到任务之后会调用w.lock加锁，因此正在执行任务中的线程已经占有了锁，无法通过shutdown方法来发送中断信号,shutdown只能中断那些还未从任务队列中拿到任务的线程
                if (!t.isInterrupted() && w.tryLock()) {
                    try {
                        //fa'zhong'duan
                        t.interrupt();
                    } catch (SecurityException ignore) {
                    } finally {
                        w.unlock();
                    }
                }
                if (onlyOne)
                    break;
            }
        } finally {
            mainLock.unlock();
        }
    }

`runWorker`方法片段：

    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                //获取任务之后会调用w.lock加锁
                w.lock();
                //...
        
(2)`tryTerminate`方法，这个方法在之前`addWorkerFailed`添加`worker`失败时介绍过，这里就不再重复介绍

`shutdownNow`方法，粗暴的关闭线程池，不再接收新任务，不再执行任务队列中剩余的任务，立即中断正在执行的任务。

    public List<Runnable> shutdownNow() {
        List<Runnable> tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess();
            //将线程池状态设置为STOP
            advanceRunState(STOP);
            //中断所有工作线程，不管有没有从任务队列中拿到任务
            interruptWorkers();
            //将任务队列中的任务移出
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
        return tasks;
    }

`interruptWorkers`方法，会中断所有线程，不管线程是否拿到任务执行：

    private void interruptWorkers() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (Worker w : workers)
                w.interruptIfStarted();
        } finally {
            mainLock.unlock();
        }
    }

`Worker.interruptIfStarted`方法：

    void interruptIfStarted() {
            Thread t;
            //getState() >= 0表明线程未拿到锁或者拿到了锁，发中断信号
            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                }
            }
        }

`drainQueue`方法，将任务队列中的任务移除到另外一个集合中：

    private List<Runnable> drainQueue() {
        BlockingQueue<Runnable> q = workQueue;
        ArrayList<Runnable> taskList = new ArrayList<Runnable>();
        q.drainTo(taskList);
        if (!q.isEmpty()) {
            for (Runnable r : q.toArray(new Runnable[0])) {
                if (q.remove(r))
                    taskList.add(r);
            }
        }
        return taskList;
    }

小结：`shutdown`方法是比较`温柔`的关闭线程池方式，会将线程池状态调整为`SHUTDOWN`，即不再接收新任务，但是会继续执行任务队列中剩余的任务，此时如果再通过`execute`方法提交任务会被拒绝，执行拒绝策略；而`shutdownNow`则是比较`粗暴`的关闭线程池方式，它直接将线程池状态`CAS`设置为`STOP`状态，即不再接收新任务，同时不会执行任务队列中剩余任务，并中断当前还在执行中的线程，它会中断所有线程，包括空闲线程(未获取`Worker`锁，也就没从任务队列中拿到任务)和执行中的线程(获取到`Worker`锁，拿到任务)。

## ReentrantLock实现机制、AQS源码分析 ##
`AQS`通过`FIFO`等待队列实现了阻塞锁和相关的同步器，内部通过一个`volatile`类型的状态变量`state`来表征锁占用状态，并且提供了针对该`state`的`CAS`修改方法，当`state`为0时，表示没有线程占有锁，当`state=1`时表示锁被占用，`state>1`时表示锁被同个线程重入，当线程释放锁时，释放一次`state-1`。`AQS`还在内部定义了一个`Node`类表示等待队列上的节点类，该队列实际上是一个`CLH`锁队列，可以查看`Node`类的定义，其中定义了4个成员变量`prev`/`next`/`waitStatus`/`thread`分别表示前驱节点、后继节点、等待状态和该节点代表的线程(该队列是所有等待锁的线程的阻塞队列，首节点是一个空节点，具体可以查看方法`enq(Node node)`源码),`waitStatus`分为5种状态：
 - `SIGNAL(-1)`:表示后继节点正在被阻塞(通过`park()`方法)，因此在该节点释放锁或者变为取消状态时必须`unpark`其后继节点
 - `CANCELLED(1)`:唯一大于0的状态值，表示该节点由于超时或者中断变为取消状态，取消的节点不会变更状态，特别是取消状态的节点不会再次阻塞
 - `CONDITION(-2)`:该节点目前在一个条件队列上，节点的线程在等待`Condition`，当其他线程调用`Condition`的`signal`方法后，当其状态变量变为0时才会被转换为同步队列节点
 - `PROPAGATE(-3)`:共享释放会被传递到其他节点
 - 0：其他状态

**`AQS`源码解析**：

`AQS`内部维护了一个由`Node`线程节点构成的同步队列，头节点是已经获取了同步状态的线程节点：

![同步队列][3]

`AQS`提供了三种同步状态相关的方法：`getState/setState/compareAndSetState`，`AQS`的获取和释放操作都是针对成员变量`state`，它可以理解为同步状态，当需要获取同步状态时，增加同步状态(`state+`)，释放同步状态时， 减少同步状态(`state-`)，`state`为0时表示此时没有任何线程获取到了同步状态，任何线程都可以参与竞争并拿到同步状态，拿到同步状态的线程等于拿到了锁，可以执行，未拿到同步状态的线程则会继续阻塞，直到被其他线程唤醒，`AQS`内部通过同步队列来维护这些线程，同时`AQS`的最佳实践是在锁的实现中继承之并作为锁的静态内部类，并实现以下几个方法：

    tryAcquire/tryRelease/tryAcquireShared/tryReleaseShared/isHeldExclusively
    
下面分别对以上几个方法的语义作介绍：

(1)`tryAcquire`:

    protected boolean tryAcquire(int arg) { //返回true表示获取同步状态成功，否则失败
        throw new UnsupportedOperationException();
    }

尝试以独占模式获取锁，该方法会检查是否能够以独占模式获取同步状态，如果可以尝试获取，如果线程调用该方法返回`false`(获取同步状态失败)，那么`acquire`方法会将该线程加入同步队列(与此同时还会阻塞该线程)，直到其他线程唤醒阻塞线程。

下面给出`ReentrantLock`的`tryAcquire`实现：
        
        //NonfairSync实现
        protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
        
        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {   //同步状态为0，表明没有线程占用同步状态，则通过CAS设置state，成功则将当前线程设置为独占线程，返回true
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {    //当前线程如果就是独占线程，那么直接重入，返回true
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;   //返回false
        }

(2)`tryRelease`:

    protected boolean tryRelease(int arg) { //返回true表示同步状态已经完全释放，即为0，其他线程可以尝试获取同步状态，否则为false
        throw new UnsupportedOperationException();
    }
    
尝试设置同步状态来反映独占下释放操作

`ReentrantLock`的`tryRelease`实现：

        protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {   //当释放之后同步状态为0时，将free设置为true，并将独占线程置空
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;    //返回free，如果free=true，则返回true，表明当前同步状态为0
        }
(3)`tryAcquireShared`:

    protected int tryAcquireShared(int arg) {   //返回值是int类型，负值表示获取失败，0表示当前获取操作成功，但是接下来的共享获取会失败，正值则表示接下来的共享获取也可能成功
        throw new UnsupportedOperationException();
    }

尝试以共享模式获取同步状态，和`tryAcquire`一样，该方法也会检查当前的同步状态是否允许该获取操作，如果允许则尝试获取

`Semaphore`中的`tryAcquireShared`实现：
        
        //NonfairSync.tryAcquireShared实现
        protected int tryAcquireShared(int acquires) {
            return nonfairTryAcquireShared(acquires);
        }
        
        final int nonfairTryAcquireShared(int acquires) {
            for (;;) {
                int available = getState();
                int remaining = available - acquires;
                if (remaining < 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;   //返回remaining，在Semaphore中remaining表示剩余许可(这里的`state`就标识许可)，剩余许可为正数，其他线程依然可以以共享模式获取许可，如果为负数表明当前线程获取许可失败，如果为0则表明无许可，其他线程无法再获取许可，除非进行释放操作释放一定量的许可
            }
        }

(4)`tryReleaseShared`:

    protected boolean tryReleaseShared(int arg) {   //如果该共享模式的释放操作能够允许等待中的获取操作成功则返回true，否则返回false
        throw new UnsupportedOperationException();
    }

`Semaphore`的`tryReleaseShared`方法：

        protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                int current = getState();
                int next = current + releases;  //增加同步状态
                if (next < current) // overflow
                    throw new Error("Maximum permit count exceeded");
                if (compareAndSetState(current, next))
                    return true;    //CAS设置成功则返回true
            }
        }

1、`acquire`：获取锁，

    public final void acquire(int arg) {
        //线程尝试获取锁
        if (!tryAcquire(arg) &&
            //tryAcquire返回false，表明其他线程拿到锁，则将当前线程封装成独占节点加入同步队列尾部，再次自旋获取锁
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }

`tryAcquire`自旋获取锁：

![tryAcquire自旋获取锁][4]

`ReentrantLock.FairSync`中的`tryAcquire()`实现：

        //当前线程尝试获取锁
    protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            //如果state变量为0，表示当前没有线程占用锁
            if (c == 0) {   
                //hasQueuedPredecessors判断当前线程之前是否还有其他线程在排队(除了head节点)
                if (!hasQueuedPredecessors() &&
                    //CAS设置state为acquires
                    compareAndSetState(0, acquires)) {
                    //设置当前线程为独占线程
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            //当前线程为独占线程，这里表示当前线程重复拿到锁，重入
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            //返回false说明当前锁已经被其他线程拿到
            return false;
        }
    }
    
    //判断队列中是否有当前线程的前置节点(除head)，即head->pre->currentThreadNode
    public final boolean hasQueuedPredecessors() {
        // The correctness of this depends on head being initialized
        // before tail and on head.next being accurate if the current
        // thread is first in queue.
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        return h != t &&
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }
    
如果`tryAcquire()`获取锁失败(表明其他线程占有锁)，那么通过`addWaiter()`将当前线程封装成`Node`节点放入同步队列队尾

同步队列入队：

![同步队列入队][5]

    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            //如果tail节点不为空，将mode设置为tail节点
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        //tail节点为空处理
        enq(node);
        return node;
    }
    
    //tail节点为空时
    private Node enq(final Node node) {
        //死循环
        for (;;) {
            Node t = tail;
            if (t == null) { 
                //如果tail=null，那么同步队列是空的，构造一个空节点，CAS设置head，继续下轮循环
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                //CAS设置tail节点为node
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }

`enq`过程包括了初始化，即队列中没有节点时，会初始化两个空节点作为`head/tail`节点：

![enq初始化][6]

然后调用`acquireQueued()`从队列中获取

    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            //死循环
            for (;;) {
                //获取node的前置节点
                final Node p = node.predecessor();
                //如果前置节点是头结点(前置节点可能为空节点或者其他线程节点，但是其waitStatus必然是Signal，具体查看shouldParkAfterFailedAcquire)，并且tryAcquire成功(此时hasQueuedPredecessors返回false，如果此时没有线程持有锁，tryAcquire返回true，当前线程拿到锁)
                if (p == head && tryAcquire(arg)) {
                    //将node设为头结点，node的前置节点出列并被GC回收
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                //node的前置节点不是head节点或者tryAcquire失败，调用shouldPark...方法判断是否需要阻塞，如果是则调用LockSupport.park()方法阻塞线程
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
    
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        //获取node前置节点等待状态
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            //前置节点状态是SIGNAL，直接返回true，表示当前节点即将要block
            return true;
        if (ws > 0) {
            //如果前置节点状态>0，即为CANCLE状态，那么跳过所有CANCLE状态节点
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            //前置节点状态为其他状态，如PROPAGATE或者0，那么CAS设置前置节点状态为Node.SIGNAL
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }

成功获取同步状态后，头节点退出同步队列：

![同步队列出列][7]

整个`acquire`的流程：

![独占式获取同步状态流程][8]

![独占式获取同步状态][9]

如上图所示，每个没有获取到同步状态(阻塞)的节点线程都在等待`head`节点释放同步状态，当其释放状态时会唤醒后继节点，后继节点被唤醒后便可以继续循环尝试获取同步状态，如果获取成功，该节点将成为`head`节点。

2、响应中断的锁方法`lockInterruptibly()`：

    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }
    
    public final void acquireInterruptibly(int arg)
            throws InterruptedException {
        //如果在方法入口检测到中断，抛出ThreadInterruptedException，并清除中断标志位          
        if (Thread.interrupted())
            throw new InterruptedException();
        //尝试获取锁
        if (!tryAcquire(arg))
            //获取锁失败
            doAcquireInterruptibly(arg);
    }
    
    //这个方法和acquireQueued很像，只是加入了中断处理
    private void doAcquireInterruptibly(int arg)
        throws InterruptedException {
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    //抛出ThreadInterruptedException
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

**公平锁和非公平锁**

`FairSync`：

    final void lock() {
            acquire(1); //获取一次锁，将state变量+1
        }
    tryAcquire()源码见上，大致流程如下：
    1、如果state=0，表明没有线程占用锁，那么如果当前线程Node没有前置节点，并且通过CAS设置state成功，那么将当前线程设置为独占线程，拥有锁，并返回true，表明尝试获取锁成功
    2、如果state非0，且当前线程就是独占线程(拥有锁的线程)，那么直接设置state，并返回true
    3、否则返回false

`NonFairSync`：

    final void lock() {
            if (compareAndSetState(0, 1))
            //CAS设置state值，成功则将当前线程设置为独占线程 
            setExclusiveOwnerThread(Thread.currentThread());
            else
            //正常获取锁流程，调用父类AQS的acquire()方法
                acquire(1);
        }
        
    protected final boolean tryAcquire(int acquires) {
            //调用非公平获取锁方法
            return nonfairTryAcquire(acquires);
        }
        
    final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
            //state=0，并且CAS设置state成功，那么直接设置当前线程为独占线程，不会考虑之前是否有其他线程在等待，这就是非公平锁
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
            //如果当前线程是独占线程，则直接设置state
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }

**共享模式**

**共享获取同步状态**

`acquireShared`方法时共享获取的入口方法：

    public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0)
            doAcquireShared(arg);
    }

先调用`tryAcquireShared`尝试以共享模式获取，如果失败则调用`doAcquireShared`方法将线程以共享模式加入同步队列并`LockSupport.park`，`tryAcquireShared`是一个空实现， 由子类重写，看一下`CountDownLatch$Sync`的实现：
    
    //如果state=0，则返回1，否则返回-1，在CountDownLatch中，state=0表示此时所有线程都阻塞在栅栏，满足被唤醒条件
    protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1;
        }

`doAcquireShared`方法将`tryAcquireShared`失败的线程加入同步队列并挂起，同时不断的自旋。

    private void doAcquireShared(int arg) {
        //将当前线程封装成共享节点加入同步队列
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            boolean interrupted = false;
            //自旋
            for (;;) {
                final Node p = node.predecessor();
                //如果前置节点是head节点
                if (p == head) {
                    //调用tryAcquireShared尝试获取共享状态
                    int r = tryAcquireShared(arg);
                    if (r >= 0) {
                        //(1)获取成功，则将node设置为head节点并propagate
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

(1)`setHeadAndPropagate`:

    private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head; // Record old head for check below
        setHead(node);
        if (propagate > 0 || h == null || h.waitStatus < 0 ||
            (h = head) == null || h.waitStatus < 0) {
            Node s = node.next;
            if (s == null || s.isShared())
                //(2)调用doReleaseShared，此时如果s=null，即head节点没有next节点，ok；如果s!=null，即head节点有next节点，此时head节点的状态一定是SIGNAL，具体参考shouldParkAfterFailedAcquire
                doReleaseShared();
        }
    }

(2)`doReleaseShared`:

    private void doReleaseShared() {
        for (;;) {
            Node h = head;
            if (h != null && h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    //unpark head后继节点
                    unparkSuccessor(h);
                }
                else if (ws == 0 &&
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head)                   // loop if head changed
                break;
        }
    }

**共享释放同步状态**

`releaseShared`方法：

    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }

同样的套路，先调用`tryReleaseShared`方法尝试释放同步状态，如果失败，则调用`doReleaseShared`方法，`tryReleaseShared`方法也是`AQS`中的一个空方法，由子类实现，返回值是`boolean`类型，返回`true`表示方法调用后能保证共享模式获取能够成功，看一下`CountDownLatch`的实现：

    protected boolean tryReleaseShared(int releases) {
            // Decrement count; signal when transition to zero
            for (;;) {
                int c = getState();
                if (c == 0)
                    return false;
                int nextc = c-1;
                if (compareAndSetState(c, nextc))
                    //如果state=0，则返回true，表示释放成功
                    return nextc == 0;
            }
        }
    
    //state=0时，返回1，意味着可以成功获取
    protected int tryAcquireShared(int acquires) {
        return (getState() == 0) ? 1 : -1;
    }

`doReleaseShared`方法，这个方法在`setHeadAndPropagate`中也可以进入：

    private void doReleaseShared() {
        for (;;) {
            Node h = head;
            if (h != null && h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    unparkSuccessor(h);
                }
                else if (ws == 0 &&
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head)                   // loop if head changed
                break;
        }
    }

![共享🔟][10]
## ConditionObject源码分析 ##
`ConditionObject`实现了`Condition`接口，其维护了两个队列：

 - `condition`等待队列：该队列中所有`Node`的`waitStatus=Node.CONDITION`，具有两个属性节点`firstWaiter`和`lastWaiter`分别表示`condition`队列的首节点和末节点
 - `sync`同步队列：参考`enq()`源码

`await()`方法源码：

    public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
            //将当前线程封装成CONDITION状态节点加入condition队列尾部
            Node node = addConditionWaiter();
            //返回到上一次同步状态
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            //如果该节点不在同步队列上，则进入while循环，此时肯定没有其他线程调用signal，因为调用signal会将线程节点转移到同步队列
            while (!isOnSyncQueue(node)) {
                //将当前线程挂起
                LockSupport.park(this);
                //检查中断
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }

`addConditionWaiter()`方法源码：

    private Node addConditionWaiter() {
            Node t = lastWaiter;
            //如果尾节点waitStatus不是CONDITION
            if (t != null && t.waitStatus != Node.CONDITION) {
                //清除所有CANCEL节点
                unlinkCancelledWaiters();
                //更新t节点
                t = lastWaiter;
            }
            Node node = new Node(Thread.currentThread(), Node.CONDITION);
            if (t == null)
                firstWaiter = node;
            else
                t.nextWaiter = node;
            lastWaiter = node;
            return node;
        }

`unlinkCancelledWaiters()`源码：
   

     //从头遍历condition队列，去除掉所有非CONDITION状态的节点，即最后所有节点状态全部变成CONDITION
        private void unlinkCancelledWaiters() {
                Node t = firstWaiter;
                //已经遍历完成的子队列的尾节点，该队列中所有节点状态都是CONDITION
                Node trail = null;
                while (t != null) {
                    Node next = t.nextWaiter;
                    if (t.waitStatus != Node.CONDITION) {
                        t.nextWaiter = null;
                        if (trail == null)
                        //将next设置为firstWaiter
                            firstWaiter = next;
                        else
                            //将trail的下一个节点设置为next
                            trail.nextWaiter = next;
                        if (next == null)
                        //没有更多的节点，更新lastWaiter为trail，这个也可以放到循环外面更新
                            lastWaiter = trail;
                    }
                    else
                //当前节点状态CONDITION，则将其设置为trail
                        trail = t;
                    //更新t节点
                    t = next;
                }
            }

`await`将同步队列中的第一个线程节点(`head`节点，获取到同步状态的节点)移动到条件队列尾部，进入阻塞状态之前会先释放同步状态，等待其他线程调用`signal`或者`signalAll`，先`wait`意味着先`signal`，`ConditionObject`内部维护了两个成员变量：`firstWaiter`和`lastWaiter`，分别表示该条件对象的第一个等待线程节点和最后一个等待线程节点

`await`将`head`线程节点从同步队列移至条件队列：

![await:sync queue->condition queue][11]

`signal()`源码：

    public final void signal() {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            if (first != null)
                //调用doSignal()方法
                doSignal(first);
        }

`doSignal()`源码：

    //从队首开始移除CANCEL节点，将非CANCEL节点transfer到sync队列
    private void doSignal(Node first) {
            do {
            //更新firstWaiter节点，因为之前的节点状态都被CANCEL，无法更改状态，需要从队列头部去掉这些节点
                if ( (firstWaiter = first.nextWaiter) == null)
                    //没有多余节点，将lastW
                    lastWaiter = null;
                //first节点无法transfer，从队列中去掉之
                first.nextWaiter = null;
            } while (!transferForSignal(first) &&
                     (first = firstWaiter) != null);
        }
        
    //等价于
    do {
        firstWaiter = first.nextWaiter;
        if (firstWaiter == null)
            lastWaiter = null;
        first.nextWaiter = null;
        first = firstWaiter;
    } while (!transferForSignal(first) && first != null)

`transferForSignal()`源码：

    final boolean transferForSignal(Node node) {
        /*
         * If cannot change waitStatus, the node has been cancelled.
         */
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;

        /*
         * Splice onto queue and try to set waitStatus of predecessor to
         * indicate that thread is (probably) waiting. If cancelled or
         * attempt to set waitStatus fails, wake up to resync (in which
         * case the waitStatus can be transiently and harmlessly wrong).
         */
        Node p = enq(node);
        int ws = p.waitStatus;
        if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }

`signal`方法会唤醒条件队列的第一个非`CANCEL`状态的节点，并将其移至同步队列队尾：

![signal:condition queue->sync queue][12]

## 信号量Semaphore ##
`Semaphore`是一个计数型信号量，内部持有一定的许可，`acquire`方法会一直阻塞，直到有可用的许可，`release`方法会释放一个许可。`Semaphore`通常用来限制访问某些资源的线程数量，例如`jdk`官方文档给出的示例`Pool`(查看文档)，利用`Semaphore`来控制访问池中对象。


    /**
     * jdk官方给的Semaphore示例
     */
    public class Pool {

        private static final int MAX_AVAILABLE = 100;
    
        private final Semaphore available = new Semaphore(MAX_AVAILABLE, true);
    
        protected Object[] items = new Object[MAX_AVAILABLE];
    
        protected boolean[] used = new boolean[MAX_AVAILABLE];
    
        /**
         * 从Pool中获取
         * @return
         * @throws InterruptedException
         */
        public Object getItem() throws InterruptedException {
            //拿到许可
            available.acquire();
            return getNextAvaliableItem();
        }
    
        /**
         * 加同步处理，获取下一个可用对象
         * @return
         */
        protected synchronized Object getNextAvaliableItem() {
            for (int i = 0; i < MAX_AVAILABLE; i++) {
                if (!used[i]) {
                    used[i] = true;
                    return items[i];
                }
            }
            return null;
        }
    
        /**
         * 将对象归还Pool
         * @param item
         */
        public void putItem(Object item) {
            if (markAsUnused(item)) {
                available.release();
            }
        }
    
        /**
         * 是否成功归还对象，加同步处理
         * @param item
         * @return
         */
        protected synchronized boolean markAsUnused(Object item) {
            for (int i = 0; i < MAX_AVAILABLE; i++) {
                if (items[i] == item) {
                    if (used[i]) {
                        used[i] = false;
                        return true;
                    } else {
                        return false;
                    }
                }
            }
            return false;
        }
    }

在获取池中对象之前，线程必须从信号量对象中获取许可，当线程用完资源后会将其返回给资源池，并将许可释放返还给信号量。

`Semaphore`如果初始化时设置许可量为1，那么该信号量的作用就相当于一个排它锁，只允许一个线程拿到许可，其他线程都会被阻塞，也叫作二进制信号量(`binary semaphore`)，此时该信号量只有两种状态：1个许可可用或者没有许可可用。二进制信号量有其他`Lock`实现没有的属性，可以在除了拥有许可的线程之外的其他线程释放锁(信号量并不知道哪个线程持有锁)，这在某些死锁恢复情况下很有用。

`Semaphore`的构造方法接收一个`boolean`参数用来指定是否公平，当设置为`false`，那么线程获取信号量的顺序无法保证。一般情况下，用来控制资源访问的信号量实现都会被初始化为公平状态，这可以防止线程饥饿的发生，当信号量用来做同步控制时，非公平状态下的吞吐量会更具优势(这也是其默认实现，避免了线程的频繁切换开销)。

在`Semaphore`中可以将**许可(permit)等价于同步状态(state)**

先看一下构造方法：
    
    //默认是非公平锁，将许可数量设置为AQS中的state，这里可以将许可(permit)等价于同步状态(state)
    public Semaphore(int permits) {
        sync = new NonfairSync(permits);
    }
    
    //另一个构造方法，可以选择设置为公平模式
    public Semaphore(int permits, boolean fair) {
        sync = fair ? new FairSync(permits) : new NonfairSync(permits);
    }

`NonfairSync`类：

    static final class NonfairSync extends Sync {
        private static final long serialVersionUID = -2694183684443567898L;

        NonfairSync(int permits) {
            super(permits);
        }
        
        //重写了AQS的tryAcquireShared方法，调用父类Sync的nonfairTryAcquireShared方法以非公平方式尝试获取许可(同步状态)
        protected int tryAcquireShared(int acquires) {
            return nonfairTryAcquireShared(acquires);
        }
    }

`FairSync`类：

    static final class FairSync extends Sync {
        private static final long serialVersionUID = 2014338818796000944L;

        FairSync(int permits) {
            super(permits);
        }
        
        //重写AQS的tryAcquireShared方法，以公平方式获取许可，返回剩下的可用许可，如果可用许可为负数，那么该线程会加入阻塞队列
        protected int tryAcquireShared(int acquires) {
            for (;;) {
                if (hasQueuedPredecessors())
                    return -1;
                int available = getState();
                int remaining = available - acquires;
                if (remaining < 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
    }
`Semaphore$Sync`类定义：

    abstract static class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 1192457210091910933L;

        Sync(int permits) {
            setState(permits);
        }
        
        //许可即同步状态
        final int getPermits() {
            return getState();
        }
        
        //非公平方式获取许可，返回剩余许可
        final int nonfairTryAcquireShared(int acquires) {
            for (;;) {
                int available = getState();
                int remaining = available - acquires;
                if (remaining < 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }

        protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                int current = getState();
                int next = current + releases;
                if (next < current) // overflow
                    throw new Error("Maximum permit count exceeded");
                if (compareAndSetState(current, next))
                    return true;
            }
        }

        final void reducePermits(int reductions) {
            for (;;) {
                int current = getState();
                int next = current - reductions;
                if (next > current) // underflow
                    throw new Error("Permit count underflow");
                if (compareAndSetState(current, next))
                    return;
            }
        }

        final int drainPermits() {
            for (;;) {
                int current = getState();
                if (current == 0 || compareAndSetState(current, 0))
                    return current;
            }
        }
    }

接下来看`Semaphore`提供的方法：

`acquire()`方法获取一个许可：

    public void acquire() throws InterruptedException {
        //可中断获取同步状态
        sync.acquireSharedInterruptibly(1);
    }
    
    //AQS.acquireSharedInterruptibly
    public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        //在获取过程中被中断，直接抛出InterruptedException异常
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) < 0)  //这里会有两种不同的实现：公平和非公平(参见上文)，tryAcquireShared如果返回负值，表明剩余许可不够，那么该线程就要进入同步队列阻塞，等待被unpark
            doAcquireSharedInterruptibly(arg);
    }
    
`acquire(int)`获取指定数量的许可，逻辑和`acquire`一样：
    
    public void acquire(int permits) throws InterruptedException {
        if (permits < 0) throw new IllegalArgumentException();
        sync.acquireSharedInterruptibly(permits);
    }

接着继续看释放许可的方法：

`release`方法，释放一个许可：

    public void release() {
        sync.releaseShared(1);
    }
    
    //AQS.releaseShared
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {    //tryReleaseShared方法在Semaphore$Sync中实现，tryReleaseShared方法返回true之后，调用doReleaseShared方法唤醒头节点后继节点线程，该线程恢复执行tryAcquireShared如果返回正值(表明之前释放了足够的许可)，并继续唤醒后继节点线程
            doReleaseShared();
            return true;
        }
        return false;
    }
    
    //Semaphore$Sync
    //释放一定量的许可，注意这里释放了一定量的许可之后，tryAcquireShared方法可能会返回正值(释放了足够的许可)，
    protected final boolean tryReleaseShared(int releases) {
        for (;;) {
            int current = getState();
            int next = current + releases;
            if (next < current) // overflow
                throw new Error("Maximum permit count exceeded");
            if (compareAndSetState(current, next))
                return true;
        }
    }
    
`release(int)`方法释放一定量的许可，其逻辑流程和`release`方法一样。


## CountDownLatch源码解析 ##

首先对`CountDownLatch`有个感性的认识，这个类的主要作用是设置阈值为`N`的栅栏，当线程调用`await`方法时会阻塞，直到其他线程调用`N`次`countDown`，所有阻塞的线程才会恢复执行。

![CountDownLatch][13]

先看看`CountDownLatch`一些重要的方法：
    
    //构造方法，传入阈值
    public CountDownLatch(int count) {
        if (count < 0) throw new IllegalArgumentException("count < 0");
        this.sync = new Sync(count);
    }
    
    //await方法，调用此方法线程会阻塞
    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    
    //超时版本的await方法
    public boolean await(long timeout, TimeUnit unit)
        throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }
    
    //countDown方法，阈值减一，调用一次释放同步状态，如果state=0会唤醒所有阻塞线程
    public void countDown() {
        sync.releaseShared(1);
    }
    
    //获取当前阈值
    public long getCount() {
        return sync.getCount();
    }
  
 可以看到上面所有的方法都调用了`sync`的相关方法，`sync`是`CountDownLatch`内部的一个成员变量，其类型是`CountDownLatch$Sync`:
 
    //继承自AQS，CountDownLatch功能实现的核心类
    private static final class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 4982264981922014374L;
        
        //传入count，也就是设置state，可以认为count等价于state
        Sync(int count) {
            setState(count);
        }
        
        //返回state值
        int getCount() {
            return getState();
        }
        
        //state=0时返回1，获取成功；否则返回-1，获取失败，失败线程会加入同步队列并park
        protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1;
        }
        
        //释放一次同步状态，如果释放之后state=0，那么返回true，否则返回false
        protected boolean tryReleaseShared(int releases) {
            // Decrement count; signal when transition to zero
            for (;;) {
                int c = getState();
                if (c == 0)
                    return false;
                int nextc = c-1;
                if (compareAndSetState(c, nextc))
                    return nextc == 0;
            }
        }
    }

**await**

`await`方法，线程调用`await`方法会阻塞，直到`state=0`：

    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    
    public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) < 0)
            doAcquireSharedInterruptibly(arg);
    }
    
    //CountDownLatch$Sycn.tryAcquireShared
    protected int tryAcquireShared(int acquires) {
        //当state=0时才会返回1，表明获取成功
        return (getState() == 0) ? 1 : -1;
    }

上面的代码基本上调用的都是`AQS`里的实现，这里就不继续说明了，大致流程就是如果`tryAcquireShared`失败(即`state!=0`)，那么就将当前线程以共享节点的形式加入同步队列并`park`。

**countDown**

`countDown`方法释放一次同步状态，如果释放后`state=0`，那么就会唤醒**所有等待的线程节点**。

    public void countDown() {
        sync.releaseShared(1);
    }
    
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            //tryReleaseShared返回true时才会调用doReleaseShared唤醒后继节点
            doReleaseShared();
            return true;
        }
        return false;
    }
    
    //CountDownLatch$Sync.tryReleaseShared
    protected boolean tryReleaseShared(int releases) {
            // Decrement count; signal when transition to zero
            for (;;) {
                int c = getState();
                if (c == 0)
                    return false;
                int nextc = c-1;
                if (compareAndSetState(c, nextc))
                    //state=0时才会返回true
                    return nextc == 0;
            }
        }

`jdk`文档给出的例子：

1、使用一个`CountDownLatch`来控制工作线程开始(一个主线程控制`N`个`worker`线程开始，需要主线程`countDown`，那么`CountDownLatch`的构造参数传1)，使用一个`CountDownLatch`来作为结束信号，当所有的`N`个工作线程都完成后(每个线程都`countDown`)唤醒主线程：

    public class Driver {

        public static void main(String[] args) throws InterruptedException {
            CountDownLatch startSignal = new CountDownLatch(1);
            CountDownLatch stopSignal = new CountDownLatch(10);
            for (int i = 0; i < 10; i++) {
                new Thread(new Worker(startSignal, stopSignal)).start();
            }
            Thread.sleep(100);
            System.out.println("工作线程开始");
            startSignal.countDown();
            stopSignal.await();
            System.out.println("工作线程全部结束");
        }
    }
    
    public class Worker implements Runnable{

        private final CountDownLatch startSignal;
    
        private final CountDownLatch stopSignal;
    
        public Worker(CountDownLatch startSignal, CountDownLatch stopSignal) {
            this.startSignal = startSignal;
            this.stopSignal = stopSignal;
        }
    
        void doWork() {
            System.out.println("i'm working");
        }
    
    
        @Override
        public void run() {
            try {
                startSignal.await();
                doWork();
                stopSignal.countDown();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

2.另外一个典型的应用就是将一个问题细分为`N`个部分，将每个部分都用`Runnable`来描述，当所有的子部分都完成之后，调度线程就会结束阻塞状态。

    class Driver { // ...
        void main() throws InterruptedException {
            CountDownLatch startSignal = new CountDownLatch(1);
            CountDownLatch doneSignal = new CountDownLatch(N);
     
            for (int i = 0; i < N; ++i) // create and start threads
              new Thread(new Worker(startSignal, doneSignal)).start();
     
            doSomethingElse();            // don't let run yet
            startSignal.countDown();      // let all threads proceed
            doSomethingElse();
            doneSignal.await();           // wait for all to finish
        }
    }

 
   

    class Worker implements Runnable {
         private final CountDownLatch startSignal;
         private final CountDownLatch doneSignal;
         Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
           this.startSignal = startSignal;
           this.doneSignal = doneSignal;
         }
         
         public void run() {
           try {
             startSignal.await();
             doWork();
             doneSignal.countDown();
           } catch (InterruptedException ex) {} // return;
         }
      
         void doWork() { ... }
         
    }

## CyclicBarrier源码分析 ##
`CyclicBarrier`从字面意义上理解就是可循环利用的栅栏，它的基本作用就是会设置一个初始阈值，线程调用`await`方法会阻塞，直到足够的线程调用了`await`方法时，所有线程都会被唤醒，其内部主要通过`ReentrantLock`和`Condition`来实现。

![CyclicBarrier][14]

首先看下其内部的成员变量：
    
    //当线程唤醒之前调用的Runnable
    private final Runnable barrierCommand;
    
    //Lock
    private final ReentrantLock lock = new ReentrantLock();
    
    //Condition
    private final Condition trip = lock.newCondition();
    
    //party的数量
    private final int parties;
    
    //剩余的线程数量，初始值是party
    private int count;
    
    //当前Generation实例
    private Generation generation = new Generation();
    
    //Generation类定义，只有一个broken
    private static class Generation {
        boolean broken = false;
    }
    
构造方法：

    public CyclicBarrier(int parties) {
        this(parties, null);
    }
    
    //可以传入barrierAction
    public CyclicBarrier(int parties, Runnable barrierAction) {
        if (parties <= 0) throw new IllegalArgumentException();
        this.parties = parties;
        this.count = parties;
        this.barrierCommand = barrierAction;
    }

`await`方法：

    public int await() throws InterruptedException, BrokenBarrierException {
        try {
            return dowait(false, 0L);
        } catch (TimeoutException toe) {
            throw new Error(toe); // cannot happen
        }
    }
    
    //超时版本的await
    public int await(long timeout, TimeUnit unit)
        throws InterruptedException,
               BrokenBarrierException,
               TimeoutException {
        return dowait(true, unit.toNanos(timeout));
    }
    
都是调用的`doAwait`方法，这个方法也是整个`CyclicBarrier`的核心方法

**doAwait**

    private int dowait(boolean timed, long nanos)
        throws InterruptedException, BrokenBarrierException,
               TimeoutException {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            final Generation g = generation;
            
            //如果栅栏broken，抛出BrokenBarrierException
            if (g.broken)
                throw new BrokenBarrierException();
            
            //如果线程被中断，唤醒所有阻塞线程，并抛出InterruptedException异常
            if (Thread.interrupted()) {
                breakBarrier();
                throw new InterruptedException();
            }
            
            //count减一
            int index = --count;
            //如果index=0即所有线程都到达了栅栏，那么会唤醒所有线程
            if (index == 0) {  // tripped
                boolean ranAction = false;
                try {
                    final Runnable command = barrierCommand;
                    //先执行barrierCommand
                    if (command != null)
                        command.run();
                    ranAction = true;
                    //(1)调用nextGeneration方法
                    nextGeneration();
                    return 0;
                } finally {
                    if (!ranAction)
                        breakBarrier();
                }
            }

            // loop until tripped, broken, interrupted, or timed out
            for (;;) {
                try {
                    if (!timed)
                        trip.await();   //阻塞当前线程
                    else if (nanos > 0L)
                        nanos = trip.awaitNanos(nanos);
                } catch (InterruptedException ie) {
                    if (g == generation && ! g.broken) {
                        breakBarrier();
                        throw ie;
                    } else {
                        // We're about to finish waiting even if we had not
                        // been interrupted, so this interrupt is deemed to
                        // "belong" to subsequent execution.
                        Thread.currentThread().interrupt();
                    }
                }

                if (g.broken)
                    throw new BrokenBarrierException();

                if (g != generation)
                    return index;

                if (timed && nanos <= 0L) {
                    breakBarrier();
                    throw new TimeoutException();
                }
            }
        } finally {
            lock.unlock();
        }
    }

## 读写锁 ##

首先看看`ReadWriteLock`接口的定义

    public interface ReadWriteLock {

        Lock readLock();    //返回读锁
    
        Lock writeLock();   //返回写锁
    }
    
其唯一实现类是`ReentrantReadWriteLock`，先看看定义的内部类：

[ReentrantReadWriteLock内部类][15]

 - `Sync`:继承自`AQS`，其内部实现了`AQS`常用的多个方法，例如`tryAcquire/tryAcquireShared/tryRelease/tryReleaseShared`
 - `FairSync/NoneFairSync`:继承自`Sync`，分别表示公平和非公平锁
 - `ReadLock/WriteLock`:分别表示读、写锁，这两个内部类是真正的`Lock`实现类，`ReentrantReadWriteLock`实现的两个方法返回的就是这两个实例

**ReentrantReadWriteLock.Sync**

先看看成员变量：

[ReentrantReadWriteLock.Sync成员变量][16]

`Sync`类的设计哲学：读写锁的锁状态被分割为两个16位(`state`本来是32位)，低字节表示独占状态获得次数(写线程，写锁，也就是说写锁同时只能一个线程获取，可以重入)，高字节表示共享状态(读线程，读锁，也就是说读锁同时可以多个线程获取，可以重入)获得次数。

        static final int SHARED_SHIFT   = 16;   //偏移量
        static final int SHARED_UNIT    = (1 << SHARED_SHIFT);  //共享状态更新单位，1左移16位，因为高字节表示共享状态的获取次数
        static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;  //锁状态重入最大次数
        static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;  //独占状态掩码?  高16位全0低16位全1
        
两个静态方法：

    static int sharedCount(int c)    { return c >>> SHARED_SHIFT; } //返回共享状态获取次数
    static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; } //返回独占状态获取次数
    
两个静态内部类：
    
    //当前线程同步状态获取次数计数器
    static final class HoldCounter {
        int count = 0;
        // Use id, not reference, to avoid garbage retention
        final long tid = getThreadId(Thread.currentThread());
    }
    
    //继承自ThreadLocal类，保存了当前线程对应的HoldCounter实例
    static final class ThreadLocalHoldCounter
        extends ThreadLocal<HoldCounter> {
        public HoldCounter initialValue() {
            return new HoldCounter();
        }
    }

其他成员变量：
    
    //当前线程重入读锁的次数
    private transient ThreadLocalHoldCounter readHolds;
    
    //上一次成功获取读锁的线程的HoldCounter缓存
    private transient HoldCounter cachedHoldCounter;
    
    private transient Thread firstReader = null;    //第一个获取读锁的线程，更准确地说是最近一个将共享状态从0置1，并且还未释放读锁的线程，如果没有这样的线程返回null
    private transient int firstReaderHoldCount; //？？？
    
接下来解析`Sync`实现的`AQS`的方法，由于写锁是独占锁，因此先看`tryAcquire/tryRelease`：

`tryAcquire`:

    protected final boolean tryAcquire(int acquires) {
            /*
             * Walkthrough:
             * 1. If read count nonzero or write count nonzero
             *    and owner is a different thread, fail.
             * 2. If count would saturate, fail. (This can only
             *    happen if count is already nonzero.)
             * 3. Otherwise, this thread is eligible for lock if
             *    it is either a reentrant acquire or
             *    queue policy allows it. If so, update state
             *    and set owner.
             */
            Thread current = Thread.currentThread();
            int c = getState();
            int w = exclusiveCount(c);  //计算独占状态(写锁获取状态)，state低16位
            if (c != 0) {   //如果state部位0
                // (Note: if c != 0 and w == 0 then shared count != 0)
                if (w == 0 || current != getExclusiveOwnerThread()) //这里分两种情况：1.如果写锁获取状态为0(w==0)，由于c!=0，即此时有线程获取读锁，那么直接返回false，即使获取读锁的是当前线程(读锁->写锁这种锁升级是不允许的)，这样的考量是为了保证数据的可见性，即如果其他线程获取了读锁，当前线程如果再获取写锁修改数据，那么这些修改对读线程是不可见的；2.如果写状态不为0且当前线程不是独占线程，那么也会直接返回false，这符合写锁是独占锁的特性，即同时只允许一个线程获取写锁，其他尝试获取写锁的线程会失败，进入同步队列
                    return false;
                if (w + exclusiveCount(acquires) > MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                // Reentrant acquire
                setState(c + acquires);
                return true;
            }
            if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
                return false;
            setExclusiveOwnerThread(current);
            return true;
        }

`tryRelease`:

        protected final boolean tryRelease(int releases) {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            int nextc = getState() - releases;
            boolean free = exclusiveCount(nextc) == 0;  //独占状态为0时，free为true
            if (free)
                setExclusiveOwnerThread(null);
            setState(nextc);
            return free;
        }
        
`tryAcquireShared`:

        protected final int tryAcquireShared(int unused) {
            /*
             * Walkthrough:
             * 1. If write lock held by another thread, fail.
             * 2. Otherwise, this thread is eligible for
             *    lock wrt state, so ask if it should block
             *    because of queue policy. If not, try
             *    to grant by CASing state and updating count.
             *    Note that step does not check for reentrant
             *    acquires, which is postponed to full version
             *    to avoid having to check hold count in
             *    the more typical non-reentrant case.
             * 3. If step 2 fails either because thread
             *    apparently not eligible or CAS fails or count
             *    saturated, chain to version with full retry loop.
             */
            Thread current = Thread.currentThread();
            int c = getState();
            if (exclusiveCount(c) != 0 &&
                getExclusiveOwnerThread() != current)   //如果有其他线程已经获取了独占状态(写锁)，那么返回-1，表示尝试获取共享状态失败
                return -1;
            int r = sharedCount(c); //共享状态获取次数(读次数) 
            if (!readerShouldBlock() &&
                r < MAX_COUNT &&
                compareAndSetState(c, c + SHARED_UNIT)) {   //未读阻塞&读次数小于最大次数&CAS设置共享状态成功
                if (r == 0) {   //如果读次数为0
                    firstReader = current;  //firstReader设置为当前线程
                    firstReaderHoldCount = 1;   //当前线程读次数置1
                } else if (firstReader == current) {    //r!=0， 如果firstReader是当前线程，那么自增firstReaderHoldCount变量
                    firstReaderHoldCount++;
                } else {    //r!=0，且当前线程不是firstReader
                    HoldCounter rh = cachedHoldCounter; //cachedHoldCounter是上一个获取读锁的线程对应的HoldCounter实例
                    if (rh == null || rh.tid != getThreadId(current))
                        cachedHoldCounter = rh = readHolds.get();  //如果rh==null或者当前线程不是上一个获取读锁的线程，那么重置cachedHoldCounter为当前线程的HoldCounter(这里使用readHolds这个ThreadLocal实例来存储当前线程对应的HoldCounter实例，可以看看ThreadLocalHoldCounter的源码)，这里有个小问题就是为什么使用cachedHoldCounter而不是直接从readHolds中获取当前线程的HoldCounter，这可能是在上一次获取读锁线程和当前线程是同一个线程的情况下能够提高效率
                    else if (rh.count == 0) //假如线程A上一次第一次获取读锁，那么rh.count==0，并且本次获取读锁的线程仍然是A线程，就是这个if所对应的情况，我觉得没必要再设置readHolds
                        readHolds.set(rh);
                    rh.count++; //增加当前线程的读锁计数count
                }
                return 1;
            }
            return fullTryAcquireShared(current);
        }

`ThreadLocalHoldCounter`源码：

        static final class ThreadLocalHoldCounter
            extends ThreadLocal<HoldCounter> {
            public HoldCounter initialValue() {
                return new HoldCounter();   //初始化HoldCounter实例
            }
        }
        
        static final class HoldCounter {
            int count = 0;  //初始化时count=0
            // Use id, not reference, to avoid garbage retention
            final long tid = getThreadId(Thread.currentThread());
        }

`tryReleaseShared`:

        protected final boolean tryReleaseShared(int unused) {
            Thread current = Thread.currentThread();
            if (firstReader == current) {   //如果当前线程是firstReader，即第一个获取读锁的线程
                // assert firstReaderHoldCount > 0;
                if (firstReaderHoldCount == 1)  //如果firstReaderCount==1，将firstReader设置为null回收
                    firstReader = null;
                else
                    firstReaderHoldCount--; //否则自减
            } else {
                HoldCounter rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                int count = rh.count;
                if (count <= 1) {   //如果count<=1，那么移除当前线程的HoldCounter
                    readHolds.remove();
                    if (count <= 0)
                        throw unmatchedUnlockException();
                }
                --rh.count; //读锁计数自减
            }
            for (;;) {
                int c = getState();
                int nextc = c - SHARED_UNIT;
                if (compareAndSetState(c, nextc))
                    // Releasing the read lock has no effect on readers,
                    // but it may allow waiting writers to proceed if
                    // both read and write locks are now free.
                    return nextc == 0;  //CAS设置共享状态成功，这里如果nextc==0返回true，否则返回false，因为nextc==0表示当前没有线程占用读锁状态，那么可以让后继的写线程成功获取到写锁，考虑这么一种情况：同步队列如下  读A -> 读B -> 写  此时读A成功获取到了共享状态(tryAcquireShared返回正值)，那么会unpark读B线程，并将读B设置为头结点 读B -> 写 读B获取到共享状态，唤醒写线程，但是写线程在有读线程获取到共享状态时是无法获取到独占状态的(tryAcquire返回-1)，那么它将一直阻塞，此时只能通过tryReleaseShared来手动释放共享状态，当且仅当释放之后的共享状态等于0时才能保证tryAcquire返回正值，即写线程能够成功获取写锁。
            }
        }
        
**读写锁的特性**

1、获取锁的顺序：公平锁和非公平锁，如果写锁被获取或者同步队列中有线程正在等待写锁，那么尝试获取公平读锁的线程将会被阻塞，只有在队列中等待最久的写线程获取写锁并释放之后，读线程才能成功获取读锁，当然，如果等待中的写线程取消等待，使得队列中一个或者读线程(连续)成为等待时间最长的线程(写锁释放)，那么这些读线程会被分配读锁；只有在读锁和写锁释放的情况下，线程才能获取到公平的写锁

2、重入：读写锁都具有重入特性，另外，写线程可以获取读锁，反之则不然，即读线程无法获取写锁(这个可以从`tryAcquire`和`tryAcquireShared`的源码来看)

    //tryAcquire片段，非阻塞获取写锁
    if (c != 0) {
        // (Note: if c != 0 and w == 0 then shared count != 0)
        if (w == 0 || current != getExclusiveOwnerThread()) //如果w==0，c!=0，即有线程获取到了读锁，即使是当前线程也会直接返回false，即上面的读线程尝试获取写锁会失败
            return false;   
    
    //tryAcquireShared片段，非阻塞获取读锁
    if (exclusiveCount(c) != 0 &&
                getExclusiveOwnerThread() != current)   //如果获取到写锁的是当前线程，那么这个if分支返回true，即上面的写线程尝试获取读锁可行
                return -1;
                
3、锁降级：允许从写锁降级成读锁，先获取写锁，再获取读锁，再释放写锁，结合`jdk`给的一个例子：

    class CachedData {
       Object data;
       volatile boolean cacheValid;
       final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    
       void processCachedData() {
         rwl.readLock().lock();
         if (!cacheValid) {
           // Must release read lock before acquiring write lock
           rwl.readLock().unlock();
           rwl.writeLock().lock();
           try {
             // Recheck state because another thread might have
             // acquired write lock and changed state before we did.
             if (!cacheValid) {
               data = ...
               cacheValid = true;
             }
             // Downgrade by acquiring read lock before releasing write lock
             rwl.readLock().lock();
           } finally {
             rwl.writeLock().unlock(); // Unlock write, still hold read
           }
         }
    
         try {
           use(data);
         } finally {
           rwl.readLock().unlock();
         }
       }
     }

4、中断
## 详解Object类wait()和notify()方法 ##
先看看文档中`wait(timeout)`方法的解释：

    
    造成当前线程的阻塞，直到其他线程调用此对象的notify()或者notifyAll()方法。当前线程必须拥有此对象的锁，调用wait方法会使当前线程释放该对象的锁，并且进入等待阻塞状态(加入条件队列，等待重新拿到对象锁，等待状态中的线程不会参与线程调度)，直到发生如下四种事情：
    1、其他线程调用该对象的notify()方法，并且阻塞线程刚好通过竞争机制获取到该对象锁，就可以被唤醒
    2、其它线程通过调用该对象的notifyAll()方法，阻塞线程会被唤醒
    3、其他线程调用Thread.interrupt()方法中断阻塞线程
    4、超时时间结束，如果timeout=0，那么不会考虑超时时间直到线程被唤醒
    如果发生上述四种情况，那么阻塞线程就会从条件队列移除，并重新参与线程调度，和其他线程竞争对象锁，处于等待阻塞状态中的线程如果重新拿到对象锁就可以恢复到wait导致的阻塞之前的状态并恢复执行(即从wait方法返回)。该方法只能在拥有对象锁的线程中调用，并且最好在while循环中以避免其他线程的中断或者虚拟唤醒，例如:
        //synchronized(obj)获取obj的Object Monitor
        synchronized(obj) {
            while(condition) {
                obj.wait();
                ...//somecode
            }
        }

    当某线程拿到对象锁后，在同步代码块中执行该对象的`wait()`方法，会使该线程暂时释放对象锁进入等待阻塞状态，处于阻塞状态的线程不会参与线程调度，当某线程获取对象锁并调用`notify()/notifyAll()`方法之后，处于阻塞状态的线程会重新进入可执行状态，并参与线程调度，如果再次获得对象锁，**将会从原来阻塞的位置继续执行代码**，如上面的`somecode`写在`obj.wait()`之后，当阻塞线程恢复执行，该代码会立即执行

`notify()`的文档解释：

    唤醒等待对象锁的某个线程，线程选择是任意和随机的，通过调用对象的wait()方法可以使线程进入等待阻塞状态。唤醒的线程只有在当前线程释放对象锁时才能执行，并且会和其他线程竞争对象锁。该方法只能在拥有对象锁的线程内调用，一个线程获取对象锁(Object Monitor)有三种方式：
    1)执行synchronized method()方法
    2)执行synchronized(obj){}包含的代码段
    3)执行synchronized(Object.class){}代码段或者执行某类的synchronized静态方法:synchronized static method()
    同一时刻，只有一个线程能拥有对象的锁，因此synchronized也叫做独占锁，悲观锁，当某线程拥有该对象锁时，其他需要获取该对象锁的线程只能等待，但是可以访问其他非同步方法

## Lock锁 ##
这里主要介绍两个接口`Lock`和`Condition`

**`Lock`**：

锁实现提供了更多可拓展性的锁操作，支持多个关联的`Condition`对象。锁对象实际上是控制多线程访问共享对象的工具，一般地，锁对象提供了共享资源的排他性访问，在同一时刻只有一个线程能够获取锁，其他所有访问共享资源的线程必须先获取锁再访问资源，然而，某些锁允许并发访问，例如读锁`ReadWriteLock`。
`synchornized`方法或者代码段提供了与对象相关的隐式对象锁，但是锁的获取和释放都是以块结构进行：获取锁的顺序和释放锁的顺序是相反的，例如下面的代码表明先获取锁`A`，再获取锁`B`，然后释放锁`B`，再释放锁`A`：

    synchronized(A) {
        synchronized(B) {
            
        }
    }

尽管`synchronized`的作用域机制使其编码更为简单，并且避免了许多涉及到锁的编程错误，但是还是有很多场合需要使用到更加灵活的锁机制，例如你需要先获取锁`A`，再获取锁`B`，然后释放`A`，获取`C`，再释放`B`获取`D`，这种场合下`synchronized`无法轻易做到，而使用`Lock`实现则很简单。

`Lock`接口使用范例：

    Lock lock = new ReentrantLock();
    lock.lock();
    try {
        ...
    } finally {
        lock.unlock();  //finally块中释放锁，原因是Lock在抛异常时不会主动释放锁，可能造成死锁
    }

`Lock`接口还提供了`tryLock`方法以非阻塞方式获取锁，`lockInterruptibly`可以响应中断的获取锁，`tryLock(timeout)`超时获取锁

`Lock`接口提供的方法：
`lock()`：获取锁

`newCondition()`：返回与`Lock`对象绑定的`Condition`实例，在等待该`Condition`之前，当前线程必须获取该锁对象，即先调用`lock.lock()`再去调用`condition.await()`，**调用`await()`方法会在进入等待阻塞状态前释放掉锁，并且在`await`返回前重新获取锁**

`lockInterruptibly`:中断式获取锁

`tryLock`:以非阻塞方式获取锁，如果获取锁成功，返回`true`，否则返回`false`

    Lock lock = new ReentrantLock();
    if(lock.tryLock()) {
        //获取锁成功
        try {
            //...
        } finally {
            lock.unlock();
        }
    } else {
        //获取锁失败
    }

`tryLock(timeout)`:超时获取锁，分三种情况返回，首先是超时时间内获取锁，其次是超时时间内被中断，最后是超时时间结束

`unlock()`：释放锁

## Lock和synchronized的选择 ##
总结来说`Lock`和`synchronized`有以下几点不同：

 - `Lock`是一个接口，而`synchronized`是`java`中的关键字，`synchronized`是内置的语言实现
 - `synchronized`在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象的发生，而`Lock`在发生异常时，如果没有主动通过`unlock`释放锁，很可能会造成死锁现象，因此使用`Lock`一定要在`finally`块中释放锁(编程范式)
 - `Lock`可以让等待锁的线程响应中断，而`synchronized`却不行，使用`synchronized`时，等待的线程会一直等待下去，不能够响应中断
 - 通过`Lock`可以知道有没有成功获取锁(`tryLock`)，而`synchronized`却无法办到
 - `Lock`可以提高多个线程进行读操作的效率

以上几点均可以从`Lock`接口提供的方法看出来。
 
**`Condition`**:

`Condition`接口将`Object`类的`wait/notify`方法析出到单独的对象中，和任意的`Lock`实现结合，`Lock`替换了`synchronized`方法和代码段，`Condition`用`await/signal`方法替换了对象的监视器方法`wait/notify`，等待一个`Condition`的一个关键属性就是它会**自动释放相关的锁并将当前线程挂起**，和`Object`的`wait()`方法一样
`Condition`对象和`Lock`对象绑定，直接用`lock.newCondition()`方法获取`Condition`对象
举个简单的例子，假设有个缓存区支持读写操作：`take`和`put`方法，如果缓存区为空，读线程就会被阻塞，如果缓存区已满，写线程就会被阻塞，每次当缓存区非空或者可取时，我们仅仅唤醒一个对应的线程，这是一种比较优化的方式：

    package demo.conpro;
    
    import java.util.concurrent.locks.Condition;
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;

    /**
     * 具有阻塞功能的缓存区，当缓存区为空时，阻塞读线程，当缓存区满时，阻塞写线程
     */
    public class BoundedBuffer {

    //锁对象
    private final Lock lock = new ReentrantLock();

    //可写标志
    private final Condition canWrite = lock.newCondition();

    //可读标志
    private final Condition canRead = lock.newCondition();

    //对象数组
    Object[] items = new Object[100];

    private int readIndex,writeIndex,count;

    public void write(Object obj) {
        lock.lock();
        try {
            while(count == items.length) {
                canWrite.await();
            }
            items[writeIndex] = obj;
            if (++writeIndex == items.length) {
                writeIndex = 0;
            }
            ++count;
            canRead.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }


    public Object read() {
        Object result = null;
        lock.lock();
        try {
            while (count == 0) {
                canRead.await();
            }
            result = items[readIndex];
            if (++readIndex == items.length) {
                readIndex = 0;
            }
            --count;
            canWrite.signal();
            return result;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return result;
    }
    }

`java.util.concurrent.ArrayBlockingQueue`类提供了这种功能，因此可以直接用该类替换数组，实现对阻塞线程的控制


## ThreadLocal源码分析 ##
`ThreadLocal`不是用来解决共享对象的多线程访问问题的，一般情况下，通过`ThreadLocal.set()`到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到。
另外，`ThreadLocal`使得各线程保持各自一个独立的对象，并不是通过`ThreadLocal.set()`来实现的，而是通过每个线程中的`new`对象来创建对象，再通过`ThreadLocal.set()`方法将该对象的引用保存到该线程的`threadLocals`中(`map`类型，是`Thread`的成员域，初始值是`null`)，键是`ThreadLocal`实例，在调用`get()`方法时，会取之前放进去的对象，如果本来该对象就是多线程共享的同一个对象，那么多线程的`ThreadLocal.get()`取得的还是这个共享对象本身，还是会存在并发访问的问题。
看一下`ThreadLocal`的具体应用：

    private static final ThreadLocal threadSession = new ThreadLocal();  
      
    public static Session getSession() throws InfrastructureException {  
        Session s = (Session) threadSession.get();  
        try {  
            if (s == null) {  
                s = getSessionFactory().openSession();  
                threadSession.set(s);  
            }  
        } catch (HibernateException ex) {  
            throw new InfrastructureException(ex);  
        }  
        return s;  
    } 
首先通过`threadSession.get()`判断当前线程中有没有保存`session`实例，如果没有那么通过`getSessionFactory().openSession()`创建一个新的`session`，并调用`threadSession.set(session)`将该`session`保存到当前线程的`threadLocals`变量中，这样可以保证每个线程都会有个自己独立的`session`对象，因此`ThreadLocal`的应用场合最适合按线程多实例(每个线程对应一个实例)的对象的访问，并且这个对象很多地方都要用到。

总之，`ThreadLocal`不是用来解决对象共享访问问题的，而主要是提供了保持对象的方法和避免参数传递的方便的对象访问方式，归纳了两点：

1、每个线程中都有一个自己的`ThreadLocal.ThreadLocalMap`对象`threadLocals`,初始值是`null`，可以将线程自己的对象保持在其中，各管各的，线程可以正确的访问自己的对象

2、将一个公用的`ThreadLocal`静态实例作为`key`，将不同对象的引用作为值保存到不同线程的`threadLocals`中，然后线程执行过程中通过这个静态`ThreadLocal`实例的`get()`方法获取自己保存的那个对象，避免了将这个对象作为参数传递的麻烦

`ThreadLocal`源码解析：
`get()`方法：

    public T get() {
        Thread t = Thread.currentThread();
        //获取当前线程的threadLocals变量(ThreadLocalMap<ThreadLocal<?>,Object>类型，初始值为null)
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            //如果map不为空，则取key为this对应的值
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        //没取到值则返回初始值
        return setInitialValue();
    }

`setInitialValue()`方法：

    private T setInitialValue() {
        //初始化值方法，默认返回null，可以被子类覆盖
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            //map非空，设置value
            map.set(this, value);
        else
            //new一个ThreadLocalMap
            createMap(t, value);
        return value;
    }

`set()`方法：

    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }

官方文档给出的一个实例：
    
    //给每个线程分配一个单独的线程ID，该线程ID在线程第一次调用ThreadId.get()方法时就会分配，以后每次调用都不会改变
    //只要线程仍存活、ThreadLocal实例可访问，那么该线程就拥有一个线程局部变量的副本的引用，当线程死亡后，如果没有其他引用指向该副本，那么该副本就会被GC回收
    public class ThreadId {
        
        private static final AtomicInteger nextId = new AtomicInteger(0);
        
        private static final ThreadLocal<Integer> threadId = new ThreadLocal<Integer>() {
            protected Integer initialValue() {
                return nextId.getAndIncrement();
            }
        };
        
        public static int get() {
            return threadId.get();
        }
    }

## 经典的Consumer/Producer ##


  [1]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png
  [2]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89.jpg
  [3]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97.png
  [4]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/tryAcquire%E8%87%AA%E6%97%8B.png
  [5]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E5%85%A5%E9%98%9F.png
  [6]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/enq.png
  [7]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E5%87%BA%E9%98%9F.png
  [8]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/%E7%8B%AC%E5%8D%A0%E5%BC%8F%E8%8E%B7%E5%8F%96%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png
  [9]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/%E7%8B%AC%E5%8D%A0%E5%BC%8F%E5%90%8C%E6%AD%A5.jpg
  [10]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/%E5%85%B1%E4%BA%AB%E5%BC%8F%E5%90%8C%E6%AD%A5.jpg
  [11]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97-%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97.png
  [12]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97-%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97.png
  [13]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/CountDownLatch.png
  [14]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/cyclicbarrier-3.png
  [15]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/%E8%AF%BB%E5%86%99%E9%94%81%E5%86%85%E9%83%A8%E7%B1%BB.jpg
  [16]: https://github.com/yudnkuku/SpringMvcDemo/blob/master/summary/java/img/Sync%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.jpg